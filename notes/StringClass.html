<html>

<head>
	<link rel="stylesheet" type="text/css" href="new.css">
	<title>Classes Part 3</title>
</head>

<body>

<a name="STRINGCLASS"></a>
<!-- ************************************************************************************************ -->
<!-- ************************************************************************************************ -->
<p class="SectionHeader">Creating a String Class
</p>


<ul>
<li>Some languages have "real" strings built-in.
<li>In C/C++, we refer to NUL terminated character arrays as strings.
<li>The Standard Template Library (STL) includes a <tt>std::string</tt> class that is much easier and more powerful than NUL terminated strings.
<li>To get a glimpse of how this works, we will implement our own String class.
<li>Our String class will be very simple.
<li>Note that there will be <b>intentional</b> bugs in this code (so we can fix them as we learn more).
</ul>

This is our minimal interface. Looking at the interface, what kind of functionality does the String class have? 
(It's important to be able to look at a public interface, typically in a header file, and determine the functionality of the
class.)
<p>

<blockquote><pre>
<b>#include</b> &lt;iostream&gt; <font color="#003399"><i>// ostream</i></font>

<b>class</b> String
{
  <b>public</b>:
    String();                 <font color="#003399"><i>// default constructor</i></font>
    String(<b>const</b> <b>char</b> *cstr); <font color="#003399"><i>// conversion constructor</i></font>
    ~String();                <font color="#003399"><i>// destructor</i></font>

      <font color="#003399"><i>// So we can use cout</i></font>
    <b>friend</b> std::ostream &amp; <b>operator</b>&lt;&lt;(std::ostream &amp;os, <b>const</b> String &amp;str);
    
  <b>private</b>:
    <b>char</b> *string_; <font color="#003399"><i>// the &quot;real&quot; string (A NUL terminated array of characters)</i></font>
};
</pre></blockquote>
  
Once these methods are implemented, this trivial program will work:

<blockquote><pre>
<b>void</b> f1()
{
  String s(<font color="#9933CC">&quot;Hello&quot;</font>);
  std::cout &lt;&lt; s &lt;&lt; std::endl;
}
</pre></blockquote>

Output:
<blockquote><pre>
Conversion constructor: Hello
Hello
Destructor: Hello
</pre></blockquote>


Implementations so far:
<p>

<table border=0 cellspacing=5 cellpadding=5>
<tr><th></th><th></th></tr>
<tr valign="top">
<td>
<blockquote><pre>
<b>#include</b> &lt;iostream&gt; <font color="#003399"><i>// iostream, cout, endl</i></font>
<b>#include</b> &lt;cstring&gt;  <font color="#003399"><i>// strcpy, strlen</i></font>
<b>#include</b> <font color="#9933CC">&quot;String.h&quot;</font>

String::String()
{
    <font color="#003399"><i>// Allocate minimal space</i></font>
  string_ = <b>new</b> <b>char</b>[1]; 
  string_[0] = 0;        
  
  std::cout &lt;&lt; <font color="#9933CC">&quot;Default constructor&quot;</font> 
            &lt;&lt; std::endl;
}
</pre></blockquote>
</td>
<td>
<blockquote><pre>
	
	
	
String::String(<b>const</b> <b>char</b> *cstr)
{
    <font color="#003399"><i>// Allocate space and copy</i></font>
  <b>int</b> len = strlen(cstr);
  string_ = <b>new</b> <b>char</b>[len + 1];
  std::strcpy(string_, cstr);      

  std::cout &lt;&lt; <font color="#9933CC">&quot;Conversion constructor: &quot;</font> 
            &lt;&lt; cstr &lt;&lt; std::endl;
}
</pre></blockquote>
</td>
</tr></table>

<table border=0 cellspacing=5 cellpadding=5>
<tr><th></th><th></th></tr>
<tr valign="top">
<td>
<blockquote><pre>
String::~String()
{
  std::cout &lt;&lt; <font color="#9933CC">&quot;Destructor: &quot;</font>
            &lt;&lt; string_ &lt;&lt; std::endl;
  <b>delete</b> [] string_; <font color="#003399"><i>// free memory</i></font>
}
</pre></blockquote>
</td>
<td>
<blockquote><pre>
std::ostream &amp; <b>operator</b>&lt;&lt;(std::ostream &amp;os, 
                          <b>const</b> String &amp;str)
{
  os &lt;&lt; str.string_;
  <b>return</b> os;
}
</pre></blockquote>
</td>
</tr></table>
	
Here's a larger example that demonstrates the construction and destruction of objects:
<p>

<table border=0 cellspacing=5 cellpadding=5>
<tr><th></th><th></th></tr>
<tr valign="top">
<td>
<blockquote><pre><b>#include</b> &lt;iostream&gt;
<b>using</b> std::cout;
<b>using</b> std::endl;

String global(<font color="#9933CC">&quot;Euclid&quot;</font>);

<b>void</b> Create1()
{
  cout &lt;&lt; <font color="#9933CC">&quot;*** Start of Create1...&quot;</font> &lt;&lt; endl;

  String local(<font color="#9933CC">&quot;Plato&quot;</font>);
  cout &lt;&lt; local &lt;&lt; endl;

  cout &lt;&lt; <font color="#9933CC">&quot;*** End of Create1...&quot;</font> &lt;&lt; endl;
}
</pre></blockquote>
</td>
<td>
<blockquote><pre>
	
	
	
	
String *Create2()
{
  cout &lt;&lt; <font color="#9933CC">&quot;*** Start of Create2...&quot;</font> &lt;&lt; endl;

  String *dynamic = <b>new</b> String(<font color="#9933CC">&quot;Pascal&quot;</font>);
  cout &lt;&lt; *dynamic &lt;&lt; endl;

  cout &lt;&lt; <font color="#9933CC">&quot;*** End of Create2...&quot;</font> &lt;&lt; endl;
  <b>return</b> dynamic;
}
</pre></blockquote>
</td>
</tr></table>

Given the functions above, what will be printed by the code below?

<blockquote><pre>
<b>int</b> main()
{
  cout &lt;&lt; <font color="#9933CC">&quot;*** Start of main...&quot;</font> &lt;&lt; endl;

    String s(<font color="#9933CC">&quot;Newton&quot;</font>);
    cout &lt;&lt; s &lt;&lt; endl;

    Create1();
    String *ps = Create2();
    cout &lt;&lt; ps &lt;&lt; endl;   <font color="#003399"><i>// what does this display?</i></font>
    cout &lt;&lt; *ps &lt;&lt; endl;  <font color="#003399"><i>// what does this display?</i></font>
    cout &lt;&lt; global &lt;&lt; endl;

    <b>delete</b> ps;

  cout &lt;&lt; <font color="#9933CC">&quot;*** End of main...&quot;</font> &lt;&lt; endl;
  <b>return</b> 0;
}
</pre></blockquote>
<br><br>
<b>Output:</b><br><br>
<blockquote><pre>
Conversion constructor: Euclid
*** Start of main...
Conversion constructor: Newton
Newton
*** Start of Create1...
Conversion constructor: Plato
Plato
*** End of Create1...
Destructor: Plato
*** Start of Create2...
Conversion constructor: Pascal
Pascal
*** End of Create2...
0x653290
Pascal
Euclid
Destructor: Pascal
*** End of main...
Destructor: Newton
Destructor: Euclid
</pre></blockquote>

Notice the two different uses of <b>new</b> and <b>delete</b> in the program:
<ul>
<li>In the constructors/destructor of the String class
<li>In the <b>Create2</b> and <b>main</b> functions of the driver program
<li>What is the purpose of each? Why are they different?
<li>Make sure you understand when (and how) destructors are called.
</ul>
<p>
At this point, we are missing quite a bit of functionality for a general purpose String class. What else could we
add to it?
<p>
		
<!--
Change the string (assign)
add (concat)
subscript
compare
strlen
-->

<!-- ************************************************************************************************ -->
<!-- ************************************************************************************************ -->
<p class="SectionHeader">Fixing the String Class
</p>

	
Here's a program that "appears" to work, but then causes a big problem:

<blockquote><pre>
<b>void</b> foo()
{
  String one(<font color="#9933CC">&quot;Pascal&quot;</font>);
  String two(one);

  cout &lt;&lt; one &lt;&lt; endl;
  cout &lt;&lt; two &lt;&lt; endl;
}
</pre></blockquote>

This is the output:

<blockquote><pre>
Pascal
Pascal
Destructor: Pascal
Destructor: ,o�a,o�a?
     69 [sig] a 1864 open_stackdumpfile: Dumping stack trace to a.exe.stackdump
     69 [sig] a 1864 open_stackdumpfile: Dumping stack trace to a.exe.stackdump
</pre></blockquote>

Notice that we initialized one String with another. It seemed to work, because we printed it out. Yet the
program still crashed. What's the problem?
<p>
<a href="#COPYDIAGRAM">Problem diagram</a>
<p>	

<p>
<hr width="90%">
<p>

Here's another similar use of the class:

<blockquote><pre>
<b>void</b> PrintString(String s)
{
  cout &lt;&lt; s &lt;&lt; endl;
}

<b>void</b> f3()
{
  String str(<font color="#9933CC">&quot;Pascal&quot;</font>);
  PrintString(str);
}
</pre></blockquote>

<b>Output:</b>
<blockquote><pre>
Conversion constructor: Pascal
Pascal
Destructor: Pascal
Destructor: ,o�a,o�a?
     63 [sig] a 836 open_stackdumpfile: Dumping stack trace to a.exe.stackdump
     63 [sig] a 836 open_stackdumpfile: Dumping stack trace to a.exe.stackdump
1599112 [sig] a 836 E:\Data\Courses\Notes\CS170\Code\Classes3\a.exe: *** fatal error - 
                    E:\Data\Courses\Notes\CS170\Code\Classes3\a.exe: *** called with threadlist_ix -1
</pre></blockquote>
<br><br>


<p>
What could possibly be causing this? 
<p>
To help understand the problem, look at the difference between these functions:

<blockquote><pre>
<b>void</b> PrintString(String s)
<b>void</b> PrintString(String &amp;s)
<b>void</b> PrintString(<b>const</b> String &amp;s)
</pre></blockquote>

<ul>
<li>What are the differences?
<li>What effect will these functions have on the program?
<li>Why would we choose one over the others?
</ul>

<!--After reviewing these functions, describe what is happening with the program. 
  Do you see the problem?
-->
<p>

<p>
<hr width="90%">
<p>

Finally, we have this that "appears" to work until it crashes:

<blockquote><pre>
<b>void</b> f5()
{
  String one(<font color="#9933CC">&quot;Pascal&quot;</font>);
  String two;

  two = one;

  cout &lt;&lt; one &lt;&lt; endl;
  cout &lt;&lt; two &lt;&lt; endl;
}
</pre></blockquote>

<b>Output:</b>
<blockquote><pre>
Conversion constructor: Pascal
Default constructor
Pascal
Pascal
Destructor: Pascal
Destructor: ,o�a,o�a?
     64 [sig] a 1164 open_stackdumpfile: Dumping stack trace to a.exe.stackdump
     64 [sig] a 1164 open_stackdumpfile: Dumping stack trace to a.exe.stackdump
1508162 [sig] a 1164 E:\Data\Courses\Notes\CS170\Code\Classes3\a.exe: *** fatal error - 
                     E:\Data\Courses\Notes\CS170\Code\Classes3\a.exe: *** called with threadlist_ix -1
</pre></blockquote>

<br>

Remember that C++ automatically provides certain member functions if you don't:

<ul>
<li>A default constructor (a constructor that doesn't require the user to provide any paramters, 
  doesn't do anything)
<li>A copy constructor (for initializing one object with another during copy initialization)
<li>A copy assignment operator (for doing copy assignments from one object to another)
<li>A destructor (doesn't do anything)
</ul>

Note that
<ul>
<li>We have defined a default constructor and destructor, so the compiler won't provide them.
<li>We don't define a copy constructor or copy assignment operator, so these will be provided by the compiler.
<li>Our program is crashing, and it's because the compiler-provided functions are inadequate.
</ul>

Adding the methods to the class:

<blockquote><pre>
<b>class</b> String
{
  <b>public</b>:
    String();                  <font color="#003399"><i>// default constructor</i></font>
    <font color="blue"><b>String(<b>const</b> String&amp; rhs);</b></font> <font color="#003399"><i>// copy constructor</i></font>
    String(<b>const</b> <b>char</b> *cstr);  <font color="#003399"><i>// conversion constructor</i></font>
    ~String();                 <font color="#003399"><i>// destructor</i></font>

      <font color="#003399"><i>// Copy assignment operator</i></font>
    <font color="blue"><b>String&amp; <b>operator</b>=(<b>const</b> String&amp; rhs);</b></font> 

      <font color="#003399"><i>// So we can use cout</i></font>
    <b>friend</b> std::ostream&amp; <b>operator</b>&lt;&lt;(std::ostream&amp; os, <b>const</b> String &amp;str);

  <b>private</b>:
    <b>char</b> *string_; <font color="#003399"><i>// the &quot;real&quot; string</i></font>
};
</pre></blockquote>

Implementations:

<table border=0 cellspacing=5 cellpadding=5>
<tr><th></th><th></th></tr>
<tr valign="top">
<td>
<blockquote><pre>
String::String(<b>const</b> String&amp; rhs)
{
  std::cout &lt;&lt; <font color="#9933CC">&quot;Copy constructor: &quot;</font> 
            &lt;&lt; rhs.string_ &lt;&lt; std::endl;

  <b>int</b> len = strlen(rhs.string_);
  string_ = <b>new</b> <b>char</b>[len + 1];
  std::strcpy(string_, rhs.string_);
}
</pre></blockquote>
</td>
<td>
<blockquote><pre>
String&amp; String::<b>operator</b>=(<b>const</b> String&amp; rhs)
{
  std::cout &lt;&lt; <font color="#9933CC">&quot;operator=: &quot;</font> 
            &lt;&lt; string_ &lt;&lt; <font color="#9933CC">&quot; = &quot;</font>
            &lt;&lt; rhs.string_ &lt;&lt; std::endl;

  <b>if</b> (&amp;rhs != <b>this</b>)
  {
    <b>delete</b> [] string_;
    <b>int</b> len = strlen(rhs.string_);
    string_ = <b>new</b> <b>char</b>[len + 1];
    std::strcpy(string_, rhs.string_);
  }

  <b>return</b> *<b>this</b>;
}
</pre></blockquote>
</td>
</tr></table>

Testing:

<table border=0 cellspacing=5 cellpadding=5>
<tr><th>Copy test</th><th>Output</th></tr>
<tr valign="top">
<td>
<blockquote><pre>
<b>void</b> f4()
{
  String one(<font color="#9933CC">&quot;Pascal&quot;</font>);
  String two(one);

  cout &lt;&lt; one &lt;&lt; endl;
  cout &lt;&lt; two &lt;&lt; endl;
}
</pre></blockquote>
</td>
<td>
<blockquote><pre>
Conversion constructor: Pascal
Copy constructor: Pascal
Pascal
Pascal
Destructor: Pascal
Destructor: Pascal
</pre></blockquote>
</td>
</tr></table>



<table border=0 cellspacing=5 cellpadding=5>
<tr><th>Assignment test</th><th>Output</th></tr>
<tr valign="top">
<td>
<blockquote><pre>
<b>void</b> f5()
{
  String one(<font color="#9933CC">&quot;Pascal&quot;</font>);
  String two;

  two = one;

  cout &lt;&lt; one &lt;&lt; endl;
  cout &lt;&lt; two &lt;&lt; endl;
}
</pre></blockquote>
</td>
<td>
<blockquote><pre>
Conversion constructor: Pascal
Default constructor
operator=:  = Pascal
Pascal
Pascal
Destructor: Pascal
Destructor: Pascal
</pre></blockquote>
</td>
</tr></table>

OK, now things are looking a little better! Let's move on...

<!-- ************************************************************************************************ -->
<!-- ************************************************************************************************ -->
<p class="SectionHeader">Enhancing the String Class
</p>

There are many features and functions we could add to the String class to make it more useable. 
<!--
Just look at the online for the string class that is part of the STL.
-->

<ul>
<li>Length of the string
<li>Comparison operators (two Strings, a String and a char *)
<li>Input operator
<li>Substring search
<li>Substring replace
<li>Uppercase/lowercase functions
<li>Converting to numbers (the string "137" would be the integer 137)
<li>Other string-related functions
</ul>

Let's do a real simple one first: The length of the string. (Call the method <b>size</b>)
<p>
	
<table border=0 cellspacing=5 cellpadding=5>
<tr><th>Declaration</th><th>Implementation</th></tr>
<tr valign="top">
<td>
<blockquote><pre>
<b>class</b> String
{
  <b>public</b>:
      <font color="#003399"><i>// Other public methods...</i></font>

      <font color="#003399"><i>// Number of chars in the string</i></font>
    <b>int</b> size() <b>const</b>;

  <b>private</b>:
    <b>char</b> *string_; <font color="#003399"><i>// the &quot;real&quot; string</i></font>
};
</pre></blockquote>
</td>
<td>
<blockquote><pre>
<b>int</b> String::size() <b>const</b>
{
    <font color="#003399"><i>// Return the length (not optimal)</i></font>
  <b>return</b> strlen(string_);
}
</pre></blockquote>
</td>
</tr></table>


<table border=0 cellspacing=5 cellpadding=5>
<tr><th>Test</th><th>Output</th></tr>
<tr valign="top">
<td>
<blockquote><pre>
String s1(<font color="#9933CC">&quot;Digipen&quot;</font>);
std::cout &lt;&lt; s1 &lt;&lt; std::endl;
std::cout &lt;&lt; <font color="#9933CC">&quot;Length of string: &quot;</font>
          &lt;&lt; s1.size() &lt;&lt; std::endl;
</pre></blockquote>
</td>
<td>
<blockquote><pre>
Conversion constructor: Digipen
<b>Digipen
Length of string: 7</b>
Destructor: Digipen
</pre></blockquote>
</td>
</tr></table>

A couple more functions:
<p>

We need to include this:
	
<blockquote><pre>
<b>#include</b> &lt;cctype&gt;   <font color="#003399"><i>// islower, isupper</i></font>
</pre></blockquote>

	
<table border=0 cellspacing=5 cellpadding=5>
<tr><th>Convert to uppercase</th><th>Convert to lowercase</th></tr>
<tr valign="top">
<td>
<blockquote><pre>
<b>void</b> String::upper()
{
  <b>int</b> len = size(); <font color="#003399"><i>// size() is linear</i></font>
  <b>for</b> (<b>int</b> i = 0; i &lt; len; i++)
    <b>if</b> (std::islower(string_[i]))
      string_[i] -= <font color="#9933CC">'a'</font> - <font color="#9933CC">'A'</font>;
}
</pre></blockquote>
</td>
<td>
<blockquote><pre>
<b>void</b> String::lower()
{
  <b>int</b> len = size(); <font color="#003399"><i>// size() is linear</i></font>
  <b>for</b> (<b>int</b> i = 0; i &lt; len; i++)
    <b>if</b> (std::isupper(string_[i]))
      string_[i] += <font color="#9933CC">'a'</font> - <font color="#9933CC">'A'</font>;
}
</pre></blockquote>
</td>
</tr></table>


<table border=0 cellspacing=5 cellpadding=5>
<tr><th>Test</th><th>Output</th></tr>
<tr valign="top">
<td>
<blockquote><pre>
String s1(<font color="#9933CC">&quot;Digipen&quot;</font>);

std::cout &lt;&lt; s1 &lt;&lt; std::endl;
s1.lower();
std::cout &lt;&lt; s1 &lt;&lt; std::endl;
s1.upper();
std::cout &lt;&lt; s1 &lt;&lt; std::endl;
</pre></blockquote>
</td>
<td>
<blockquote><pre>
Conversion constructor: Digipen
<b>Digipen
digipen
DIGIPEN</b>
Destructor: DIGIPEN
</pre></blockquote>
</td>
</tr></table>

How about comparing two Strings?
<p>
	
<blockquote><pre>
<b>void</b> f3()
{
  String s1(<font color="#9933CC">&quot;One&quot;</font>);
  String s2(<font color="#9933CC">&quot;Two&quot;</font>);

  <b>if</b> (s1 &lt; s2)
    std::cout &lt;&lt; s1 &lt;&lt; <font color="#9933CC">&quot; is before &quot;</font> &lt;&lt; s2 &lt;&lt; std::endl;
  <b>else</b>
    std::cout &lt;&lt; s1 &lt;&lt; <font color="#9933CC">&quot; is not before &quot;</font> &lt;&lt; s2 &lt;&lt; std::endl;

  <b>if</b> (s2 &lt; s1)
    std::cout &lt;&lt; s2 &lt;&lt; <font color="#9933CC">&quot; is before &quot;</font> &lt;&lt; s1 &lt;&lt; std::endl;
  <b>else</b>
    std::cout &lt;&lt; s2 &lt;&lt; <font color="#9933CC">&quot; is not before &quot;</font> &lt;&lt; s1 &lt;&lt; std::endl;

  <b>if</b> (s1 &lt; s1)
    std::cout &lt;&lt; s1 &lt;&lt; <font color="#9933CC">&quot; is before &quot;</font> &lt;&lt; s1 &lt;&lt; std::endl;
  <b>else</b>
    std::cout &lt;&lt; s1 &lt;&lt; <font color="#9933CC">&quot; is not before &quot;</font> &lt;&lt; s1 &lt;&lt; std::endl;
}
</pre></blockquote>

<b>Output:</b>
<blockquote><pre>
Conversion constructor: One
Conversion constructor: Two
<b>One is before Two
Two is not before One
One is not before One</b>
Destructor: Two
Destructor: One
</pre></blockquote>

Declaration in the <i>String</i> class:
<blockquote><pre>
<b>bool</b> <b>operator</b>&lt;(<b>const</b> String&amp; rhs) <b>const</b>;
</pre></blockquote>

Implementation:
<blockquote><pre>
<b>bool</b> String::<b>operator</b>&lt;(<b>const</b> String&amp; rhs) <b>const</b>
{
    <font color="#003399"><i>// if we're 'less' than rhs</i></font>
  <b>if</b> (std::strcmp(string_, rhs.string_) &lt; 0)
    <b>return</b> <b>true</b>;
  <b>else</b>
    <b>return</b> <b>false</b>;
}
</pre></blockquote>



Implementing these operators is also trivial:
<blockquote><pre>
<b>bool</b> <b>operator</b>&gt;(<b>const</b> String&amp; rhs) <b>const</b>;
<b>bool</b> <b>operator</b>==(<b>const</b> String&amp; rhs) <b>const</b>;
<b>bool</b> <b>operator</b>&lt;=(<b>const</b> String&amp; rhs) <b>const</b>;
<b>bool</b> <b>operator</b>&gt;=(<b>const</b> String&amp; rhs) <b>const</b>;
<b>bool</b> <b>operator</b>!=(<b>const</b> String&amp; rhs) <b>const</b>;
<b>bool</b> <b>operator</b>==(<b>const</b> String&amp; rhs) <b>const</b>;
</pre></blockquote>

What about this?

<blockquote><pre>
String s1(<font color="#9933CC">&quot;Digipen&quot;</font>);

<b>if</b> (s1 &lt; <font color="#9933CC">&quot;Hello&quot;</font>)
  std::cout &lt;&lt; <font color="#9933CC">&quot;Hello is less&quot;</font> &lt;&lt; std::endl;
<b>else</b>
  std::cout &lt;&lt; <font color="#9933CC">&quot;Hello is NOT less&quot;</font> &lt;&lt; std::endl;
</pre></blockquote>

Output:
<blockquote><pre>
Conversion constructor: Digipen
<font color="blue">Conversion constructor: Hello
Destructor: Hello</font>
Destructor: Digipen
</pre></blockquote>


<br><br>
What about this?

<blockquote><pre>
String s1(<font color="#9933CC">&quot;Digipen&quot;</font>);

<b>if</b> (<font color="#9933CC">&quot;Hello&quot;</font> &lt; s1)
  std::cout &lt;&lt; <font color="#9933CC">&quot;Hello is less&quot;</font> &lt;&lt; std::endl;
<b>else</b>
  std::cout &lt;&lt; <font color="#9933CC">&quot;Hello is NOT less&quot;</font> &lt;&lt; std::endl;
</pre></blockquote>


<br><br>
This is what we get:
<blockquote><pre>
In function 'void f4()':
error: no match for 'operator<' (operand types are 'const char [6]' and 'String')
   if ("Hello" < s1)
               ^
</pre></blockquote>
We could require the user to do this:

<blockquote><pre>
<b>if</b> (String(<font color="#9933CC">&quot;Hello&quot;</font>) &lt; s1)
</pre></blockquote>

<!--
if it was this: if (s1 < "Hello") then the conversion ctor would 
have been automatically called (until it's marked explicit)
-->

<br><br><br>

which is cumbersome. Or, we could overload a global operator to do the conversion:


<table border=0 cellspacing=5 cellpadding=5>
<tr><th></th><th></th></tr>
<tr valign="top">
<td>
<blockquote><pre>
<b>bool</b> <b>operator</b>&lt;(<b>const</b> <b>char</b> *lhs, <b>const</b> String&amp; rhs)
{
  <b>return</b> String(lhs) &lt; rhs;
}
</pre></blockquote>
</td>
<td>
<blockquote><pre>
Conversion constructor: Digipen
<font color="blue">Conversion constructor: Hello
Destructor: Hello</font>
<b>Hello is NOT less</b>
Destructor: Digipen
</pre></blockquote>
</td>
</tr></table>

<blockquote><pre>
</pre></blockquote>

Now the user can compare <i>Strings</i> with NUL-terminated strings as easily as comparing two <i>Strings</i>.
This is the whole point of overloading operators: Give the users the ability to work with user-defined
types as naturally as they work with built-in types (e.g. integers).
<p>
<b>Going one step further</b>
<p>
It would be nice if we could <i>directly</i> compare a <i>String</i> with a NUL-terminated string without
having to construct a temporary <i>String</i> first. We can do that if we can access the underlying 
NUL-terminated string. (Remember, the <i>String</i> class is just a wrapper around a C-style NUL-terminated
string.)

<table border=0 cellspacing=5 cellpadding=5>
<tr><th></th><th></th></tr>
<tr valign="top">
<td>
<blockquote><pre>
<font color="#003399"><i>// declare in public section of .h file </i></font>
<b>const</b> <b>char</b> *c_str() <b>const</b>;
</pre></blockquote>
</td>
<td>
<blockquote><pre>
<font color="#003399"><i>// implement in .cpp file</i></font>
<b>const</b> <b>char</b> *String::c_str() <b>const</b>
{
  <b>return</b> string_;
}
</pre></blockquote>
</td>
</tr></table>

Now our global less-than operator looks like this:

<blockquote><pre>
<b>bool</b> <b>operator</b>&lt;(<b>const</b> <b>char</b> *lhs, <b>const</b> String&amp; rhs)
{
  <b>return</b> std::strcmp(lhs, <font color="blue"><b>rhs.c_str()</b></font>) &lt; 0;
}
</pre></blockquote>

Now this code is more efficient:

<blockquote><pre>
String s1(<font color="#9933CC">&quot;Digipen&quot;</font>);
  
<b>if</b> (<font color="#9933CC">&quot;Hello&quot;</font> &lt; s1)
  std::cout &lt;&lt; <font color="#9933CC">&quot;Hello is less&quot;</font> &lt;&lt; std::endl;
<b>else</b>
  std::cout &lt;&lt; <font color="#9933CC">&quot;Hello is NOT less&quot;</font> &lt;&lt; std::endl;
</pre></blockquote>

<blockquote><pre>
</pre></blockquote>

<br>

<table border=0 cellspacing=0 cellpadding=0>
<tr><th>New output</th><th>Old output</th></tr>
<tr valign="top">
<td>
<blockquote><pre>
Conversion constructor: Digipen
<b>Hello is NOT less</b>
Destructor: Digipen
</pre></blockquote>
</td>
<td>
<blockquote><pre>
Conversion constructor: Digipen
<font color="blue">Conversion constructor: Hello
Destructor: Hello</font>
<b>Hello is NOT less</b>
Destructor: Digipen
</pre></blockquote>
</td>
</tr></table>

We can also "optimize" the member function by overloading it:

<blockquote><pre>
<font color="#003399"><i>// optimization</i></font>
<b>bool</b> String::<b>operator</b>&lt;(<b>const</b> <b>char</b> *rhs) <b>const</b>
{
    <font color="#003399"><i>// if we're 'less' than rhs</i></font>
  <b>if</b> (std::strcmp(string_, rhs) &lt; 0)
    <b>return</b> <b>true</b>;
  <b>else</b>
    <b>return</b> <b>false</b>;
}
</pre></blockquote>

This function does not need to make a temporary copy before comparing.

<blockquote><pre>
<b>bool</b> <b>operator</b>&lt;(<b>const</b> <b>char</b> *lhs, <b>const</b> String&amp; rhs) <font color="#003399"><i>// global, e.g. "Hello" < s1</i></font>
<b>bool</b> String::<b>operator</b>&lt;(<b>const</b> String&amp; rhs) <b>const</b>    <font color="#003399"><i>// member, e.g. s1 < s2</i></font>
<b>bool</b> String::<b>operator</b>&lt;(<b>const</b> <b>char</b> *rhs) <b>const</b>      <font color="#003399"><i>// member, e.g. s1 < "Hello"</i></font>
</pre></blockquote>

<!--

Or, do it this way:
<p>
<table border=0 cellspacing=5 cellpadding=5>
<tr><th></th><th></th></tr>
<tr valign="top">
<td>
<blockquote><pre>
  <font color="#003399"><i>// global function</i></font>
<b>bool</b> <b>operator</b>&lt;(<b>const</b> <b>char</b> *lhs, <b>const</b> String&amp; rhs)
{
  <b>return</b> (rhs &gt;= lhs);
}

  <font color="#003399"><i>// member function</i></font>
<b>bool</b> String::<b>operator</b>&gt;=(<b>const</b> String&amp; rhs) <b>const</b>
{
    <font color="#003399"><i>// if we're not 'less', we're &gt; or ==</i></font>
  <b>return</b> !(String(string_) &lt; rhs);
}

  <font color="#003399"><i>// member function</i></font>
<b>bool</b> String::<b>operator</b>&lt;(<b>const</b> String&amp; rhs) <b>const</b>
{
    <font color="#003399"><i>// if we're 'less' than rhs</i></font>
  <b>if</b> (std::strcmp(string_, rhs.string_) &lt; 0)
    <b>return</b> <b>true</b>;
  <b>else</b>
    <b>return</b> <b>false</b>;
}
</pre></blockquote>
</td>
<td>
<blockquote><pre>
Conversion constructor: Digipen
Conversion constructor: Hello
Conversion constructor: Digipen
Destructor: Digipen
Destructor: Hello
<b>Hello is NOT less</b>
Destructor: Digipen
</pre></blockquote>
</td>
</tr></table>

<blockquote>
<p class="technote">
<b>Insight</b>: Take some time and understand exactly why each of the lines are printed above. How can you
"optimize" the behavior so less work is done at runtime. 
</p>
</blockquote>
-->


<blockquote><pre>
</pre></blockquote>


<!-- ************************************************************************************************ -->
<!-- ************************************************************************************************ -->
<p class="SectionHeader">More Enhancements to the <tt>String</tt> Class
</p>

There is an obvious feature that is missing from the <tt>String</tt> class: subscripting. We should
be able to do this:

<blockquote><pre>
String s1(<font color="#9933CC">&quot;Digipen&quot;</font>);

  <font color="#003399"><i>// c should have the value 'g'</i></font>
<b>char</b> c = s1[2]; 
</pre></blockquote>

Like the other operators, this is also trivial:

<table border=0 cellspacing=5 cellpadding=5>
<tr><th>Declaration</th><th>Implementation</th></tr>
<tr valign="top">
<td>
<blockquote><pre>
<b>class</b> String
{
  <b>public</b>:
    <b>char</b> <b>operator</b>[](<b>int</b> index) <font color="blue"><b>const</b></font>;
};
</pre></blockquote>
</td>
<td>
<blockquote><pre>
<b>char</b> String::<b>operator</b>[](<b>int</b> index) <b>const</b>
{
  <b>return</b> string_[index];
}
</pre></blockquote>
</td>
</tr></table>


<table border=0 cellspacing=5 cellpadding=5>
<tr><th>Sample usage</th><th>Output</th></tr>
<tr valign="top">
<td>
<blockquote><pre>
<b>void</b> f1()
{
  String s1(<font color="#9933CC">&quot;Digipen&quot;</font>);

  <b>for</b> (<b>int</b> i = 0; i &lt; s1.size(); i++)
    std::cout &lt;&lt; s1[i] &lt;&lt; std::endl;
}
</pre></blockquote>
</td>
<td>
<blockquote><pre>
D
i
g
i
p
e
n
</pre></blockquote>
</td>
</tr></table>

<b>Notes:</b>
<ul>
<li>We are using the <tt>size()</tt> method to insure we don't go too far.</li>
<li>The method is marked <b>const</b>, since we're not modifying the String.</li>
<li>There is nothing preventing the user from asking for <tt>s1[100]</tt>.
<ul>
<li>We could guard against that situation:
<blockquote><pre>
<b>char</b> String::<b>operator</b>[](<b>int</b> index) <b>const</b>
{
    <font color="#003399"><i>// Validate the index</i></font>
  <b>if</b> ( (index &gt;= 0) && (index &lt; size()) )
    <b>return</b> string_[index];
  <b>else</b>
    <b>return</b> string_[0]; <font color="#003399"><i>// What to return??? This is a BIG problem</i></font>
                       <font color="#003399"><i>//   that we'll postpone for now. (EH)</i></font>
}
</pre></blockquote>
</ul>
</ul>

Now, we want to change/modify a character in the string:


<table border=0 cellspacing=5 cellpadding=5>
<tr><th></th><th>Compiler error:</th></tr>
<tr valign="top">
<td>
<blockquote><pre>
<b>void</b> f4()
{
  String s1(<font color="#9933CC">&quot;Hello&quot;</font>);

    <font color="#003399"><i>// change first letter</i></font>
  s1[0] = <font color="#9933CC">'C'</font>;

  std::cout &lt;&lt; s1 &lt;&lt; std::endl;
}
</pre></blockquote>
</td>
<td>
<blockquote><pre>
error: non-lvalue in assignment




<----- can't assign to a temporary value
</pre></blockquote>
</td>
</tr></table>


We can't return a temporary value if we want to modify it. We must return a reference:
<p>

<table border=0 cellspacing=5 cellpadding=5>
<tr><th>Return a reference</th><th>Compiles and runs</th></tr>
<tr valign="top">
<td>
<blockquote><pre>
<font color="blue"><b>char</b>&amp;</font> String::<b>operator</b>[](<b>int</b> index) <b>const</b>
{
  <b>return</b> string_[index];
}
</pre></blockquote>
</td>
<td>
<blockquote><pre>
<b>Output:</b>

Cello
</pre></blockquote>
</td>
</tr></table>


Let's try some tests that most beginners (and students) forget to do (even if told directly to do so!):
Read a <tt><b>const</b></tt> object:
<p>

<table border=0 cellspacing=5 cellpadding=5>
<tr><th>Try a <tt>const</tt> object</th><th>Compiles and runs fine</th></tr>
<tr valign="top">
<td>
<blockquote><pre>
<b>void</b> f5()
{
  <b>const</b> String s1(<font color="#9933CC">&quot;Digipen&quot;</font>);

  <b>for</b> (<b>int</b> i = 0; i &lt; s1.size(); i++)
    std::cout &lt;&lt; s1[i] &lt;&lt; std::endl;
}
</pre></blockquote>
</td>
<td>
<blockquote><pre>
D
i
g
i
p
e
n
</pre></blockquote>
</td>
</tr></table>

Change (write) a <tt><b>const</b></tt> object:
<p>
	
<table border=0 cellspacing=5 cellpadding=5>
<tr><th>Modify const object</th><th>No problemo</th></tr>
<tr valign="top">
<td>
<blockquote><pre>
<b>void</b> f6()
{
  <b>const</b> String s1(<font color="#9933CC">&quot;Hello&quot;</font>);

    <font color="#003399"><i>// Change the const object</i></font>
  s1[0] = <font color="#9933CC">'C'</font>;

  std::cout &lt;&lt; s1 &lt;&lt; std::endl;
}

</pre></blockquote>
</td>
<td>
<blockquote><pre>
<b>Output:</b>

Cello
</pre></blockquote>
</td>
</tr></table>


What?!?!?!?!? 
<br><br>
<p>
	
<table border=0 cellspacing=5 cellpadding=5>
<tr><th>Return a const reference</th><th>Compiler error as expected</th></tr>
<tr valign="top">
<td>
<blockquote><pre>
<b><font color="blue">const</font></b> <b>char</b>&amp; String::<b>operator</b>[](<b>int</b> index) <b>const</b>
{
  <b>return</b> string_[index];
}
</pre></blockquote>
</td>
<td>
<blockquote><pre>
error: assignment of read-only 
       location
</pre></blockquote>
</td>
</tr></table>

However, this breaks our previously working and legal code:

<blockquote><pre>
<b>void</b> f4()
{
  String s1(<font color="#9933CC">&quot;Hello&quot;</font>);

    <font color="#003399"><i>// Compiler error: assignment of read-only location</i></font>
  s1[0] = <font color="#9933CC">'C'</font>;

  std::cout &lt;&lt; s1 &lt;&lt; std::endl;
}
</pre></blockquote>

<br><br>
The solution: We need to support both:
<p>
	
<blockquote><pre>
<b>void</b> f7()
{
  String s1(<font color="#9933CC">&quot;Hello&quot;</font>);         <font color="#003399"><i>// non-const object</i></font>
  <b>const</b> String s2(<font color="#9933CC">&quot;Goodbye&quot;</font>); <font color="#003399"><i>// const object</i></font>

    <font color="#003399"><i>// non-const: This should be allowed</i></font>
  s1[0] = <font color="#9933CC">'C'</font>;

    <font color="#003399"><i>// const: This should produce an error</i></font>
  s2[0] = <font color="#9933CC">'F'</font>;
}
</pre></blockquote>

We need to overload the subscript operator so that it can handle both return types. Here's our first failed attempt at the
function declarations:

<blockquote><pre>
<b>const</b> <b>char</b>&amp; <b>operator</b>[](<b>int</b> index) <b>const</b>; <font color="#003399"><i>// for r-values</i></font>
      <b>char</b>&amp; <b>operator</b>[](<b>int</b> index) <b>const</b>; <font color="#003399"><i>// for l-values</i></font>
</pre></blockquote>

and the implementations:
<p>
	
<table border=0 cellspacing=5 cellpadding=5>
<tr><th></th><th></th></tr>
<tr valign="top">
<td>
<blockquote><pre>
<b>const</b> <b>char</b>&amp; String::<b>operator</b>[](<b>int</b> index) <b>const</b>
{
  <b>return</b> string_[index];
}
</pre></blockquote>
</td>
<td>
<blockquote><pre>
<b>char</b>&amp; String::<b>operator</b>[](<b>int</b> index) <b>const</b>
{
  <b>return</b> string_[index];
}
</pre></blockquote>
</td>
</tr></table>

What is wrong with these? (They won't compile)
<!--
Return type is not part of the signature so they are identical.
The declarations will compile (prototypes), but not the definitions.
-->


<p><br><br>
They are both <tt><b>const</b></tt> methods, since neither one is modifying the private fields.
<p>
One returns a const reference and the other returns a non-const reference.
<p>

The proper way:

<blockquote><pre>
<b>const</b> <b>char</b>&amp; <b>operator</b>[](<b>int</b> index) <b>const</b>; <font color="#003399"><i>// for r-values</i></font>
      <b>char</b>&amp; <b>operator</b>[](<b>int</b> index);       <font color="#003399"><i>// for l-values</i></font>
</pre></blockquote>
	
<blockquote>
<big><center>
<p class="technote">	
The <tt><b>const</b></tt> at the end is part of the method's signature and the compiler uses it 
to distinguish between the two methods.
</p>
</center></big>
</blockquote>

Example code now works as expected:

<blockquote><pre>
<b>void</b> f8()
{
  String s1(<font color="#9933CC">&quot;Hello&quot;</font>);         <font color="#003399"><i>// non-const object</i></font>
  <b>const</b> String s2(<font color="#9933CC">&quot;Goodbye&quot;</font>); <font color="#003399"><i>// const object</i></font>

    <font color="#003399"><i>// Calls non-const version, l-value assignment (write) is OK</i></font>
  s1[0] = <font color="#9933CC">'C'</font>;

    <font color="#003399"><i>// Calls const version, l-value assignment (write) is an error</i></font>
  <font color="#003399"><i>//s2[0] = 'F';</i></font>

    <font color="#003399"><i>// Calls non-const version, r-value read is OK</i></font>
  <b>char</b> c1 = s1[0];

    <font color="#003399"><i>// Calls const version, r-value read is OK</i></font>
  <b>char</b> c2 = s2[0];
}
</pre></blockquote>


Notes:
<ul>
<li>You will usually provide two overloaded subscript operators (const and non-const).</li>
<li>Unlike C-style arrays, the <tt>String</tt> class knows how many characters it contains.</li>
<ul>
	<li>This allows it to perform validation and protect the memory to some degree.</li>
</ul>
<li>What do you do when the index is invalid?</li>
<ol>
<li>Do nothing. Let the program behave badly.</li>
<ul>
<li>This is what C++ does with built-in arrays.</li>
</ul>
<li>Return nothing</li>
<ul>
<li>Can't, the function <b>must</b> return something.</li>
</ul>
<li>Return some arbitrary valid element.</li>
<ul>
<li>Hides the problem from the user (not good).</li>
</ul>
<li>Abort the program.</li>
<ul>
That's harsh, dude. But, they probably deserved it.</li>
</ul>
<li>Something else</li>
<ul>
  <li>But what?</li>
</ul>
</ol>
<li>None of these first 4 solutions is very good.
<li>A good solution is to use <i>exceptions</i> (#5 something else).</li>
<ul>
<li>We'll talk about those later.</li>
</ul>
</ul>	

<!-- ************************************************************************************************ -->
<!-- ************************************************************************************************ -->
<p class="SectionHeader">Class Methods and <tt>static</tt> Members
</p>

Suppose we add a public data member to the <tt>String</tt> class:
<p>
	
<blockquote><pre>
<b>class</b> String
{
  <b>public</b>:
    <font color="#003399"><i>// Other public members...</i></font>

    <b>int</b> foo; <font color="#003399"><i>// public data member</i></font>

  <b>private</b>:
    <b>char</b> *string_; <font color="#003399"><i>// the &quot;real&quot; string</i></font>
};
</pre></blockquote>

<table border=0 cellspacing=5 cellpadding=5>
<tr><th>Test code</th><th>Output</th></tr>
<tr valign="top">
<td>
<blockquote><pre>
<b>void</b> f5()
{
  String s1(<font color="#9933CC">&quot;foo&quot;</font>);
  String s2(<font color="#9933CC">&quot;bar&quot;</font>);
  String s3(<font color="#9933CC">&quot;baz&quot;</font>);

  s1.foo = 10;
  s2.foo = 20;
  s3.foo = 30;

  std::cout &lt;&lt; s1.foo &lt;&lt; std::endl;
  std::cout &lt;&lt; s2.foo &lt;&lt; std::endl;
  std::cout &lt;&lt; s3.foo &lt;&lt; std::endl;
}
</pre></blockquote>
</td>
<td>
<blockquote><pre>
Conversion constructor: foo
Conversion constructor: bar
Conversion constructor: baz
10
20
30
Destructor: baz
Destructor: bar
Destructor: foo
</pre></blockquote>
</td>
</tr></table>

Of course, if we don't initialize the data in the constructor or in this code, we get different output:
  
<table border=0 cellspacing=5 cellpadding=5>
<tr><th></th><th></th></tr>
<tr valign="top">
<td>
<blockquote><pre>
<b>void</b> f6()
{
  String s1(<font color="#9933CC">&quot;foo&quot;</font>);
  String s2(<font color="#9933CC">&quot;bar&quot;</font>);
  String s3(<font color="#9933CC">&quot;baz&quot;</font>);

  std::cout &lt;&lt; s1.foo &lt;&lt; std::endl;
  std::cout &lt;&lt; s2.foo &lt;&lt; std::endl;
  std::cout &lt;&lt; s3.foo &lt;&lt; std::endl;
}
</pre></blockquote>
</td>
<td>
<blockquote><pre>
Conversion constructor: foo
Conversion constructor: bar
Conversion constructor: baz
1627408208
4268368
4268368
Destructor: baz
Destructor: bar
Destructor: foo
</pre></blockquote>
</td>
</tr></table>
<p>
	
So this code:	
<blockquote><pre>
String s1(<font color="#9933CC">&quot;foo&quot;</font>);
String s2(<font color="#9933CC">&quot;bar&quot;</font>);
String s3(<font color="#9933CC">&quot;baz&quot;</font>);
s1.foo = 10;
s2.foo = 20;
s3.foo = 30;
</pre></blockquote>
	
would produce something like this in memory:

<blockquote>
<img src="Classes-String3-1.png">
</blockquote>


We must always initialize any <i>non-static</i> data in the class, otherwise it's undefined. Non-static? As opposed to what? Static?
<p>
By default, members of a class are non-static. If you want them to be static, you must indicate it with the
<tt><b>static</b></tt> keyword. 

<center>
<p class="technote">
Unfortunately, the meaning of <tt><b>static</b></tt> is completely different from the other meanings we've learned.
</p>
</center>

Adding a <tt><b>static</b></tt> member is trivial:
<p>
	
<blockquote><pre>
<b>class</b> String
{
  <b>public</b>:
    <font color="#003399"><i>// Other public members...</i></font>

    <b>int</b> foo;        <font color="#003399"><i>// non-static</i></font>
    <b>static</b> <b>int</b> bar; <font color="#003399"><i>// static</i></font>

  <b>private</b>:
    <b>char</b> *string_; <font color="#003399"><i>// the &quot;real&quot; string</i></font>
};
</pre></blockquote>


<blockquote><pre>
</pre></blockquote>
  

<blockquote><pre>
</pre></blockquote>

<ul>
<li><tt><b>static</b></tt> members do not "live" within each instance (like non-static members).
<li>There is only one copy and it is shared between all instances.
<li>This means that you do not need to instantiate (create) an object before using a <tt><b>static</b></tt> member.
<li>How do you access a <tt><b>static</b></tt> member if you don't have an object?
<blockquote><pre>
  <font color="#003399"><i>// Accessing a static member with the scope resolution operator</i></font>
<b>int</b> i = String::bar;
std::cout &lt;&lt; i &lt;&lt; std::endl;
</pre></blockquote>
<li>If there is no object, then there is no constructor. How do you initialize the <tt><b>static</b></tt> member?

  

<p>
	
<table border=0 cellspacing=5 cellpadding=5>
<tr><th>Header file (.h)</th><th>Implementation file (.cpp)</th></tr>
<tr valign="top">
<td>
<blockquote><pre>
<b>class</b> String
{
  <b>public</b>:
    String();                   <font color="#003399"><i>// default ctor</i></font>
    String(<b>const</b> String&amp; rhs); <font color="#003399"><i>// copy ctor</i></font>
    ~String();                  <font color="#003399"><i>// dtor</i></font>

      <font color="#003399"><i>// declaration</i></font>
    <font color="blue"><b><b>static</b> <b>int</b> bar;</b></font> <font color="#003399"><i>// static</i></font>
    
    <font color="#003399"><i>// etc...</i></font>
};
</pre></blockquote>
</td>
<td>
<blockquote><pre>
<b>#include</b> <font color="#9933CC">&quot;String.h&quot;</font>

<font color="#003399"><i>// Initialize outside of the class (Definition)</i></font>
<font color="blue"><b><b>int</b> String::bar = 0;</b></font>

String::String()
{
  string_ = <b>new</b> <b>char</b>[1]; 
  string_[0] = 0;        
}

String::~String()
{
  <b>delete</b> [] string_;
}

<font color="#003399"><i>// etc...</i></font>

</pre></blockquote>
</td>
</tr></table>
</ul>


If you fail to define the static member outside of the class, you will get a linker error:

<blockquote><pre>
/cygdrive/h/temp/ccZm55jF.o:main.cpp:(.text+0xf8d): <b>undefined reference to 'String::bar'</b>
collect2: ld returned 1 exit status
</pre></blockquote>

Note that you must do it this way:

<blockquote><pre>
<b>int</b> String::bar = 0;</b> <font color="#003399"><i>// Need the leading <b>int</b> keyword (It's a definition)</i></font>
</pre></blockquote>

Just doing this:

<blockquote><pre>
<b>String::bar = 0;</b> <font color="#003399"><i>// Assignment</i></font>
</pre></blockquote>

is simply assigning a new value to <i>String::bar</i>.
<p>
Each object has a separate storage area for <tt>foo</tt>, but <tt>bar</tt> is shared between them:

<blockquote>
<img src="Classes-String3-1.png">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="Classes-String-static-1.png">
</blockquote>

<center>
<p class="technote">
Note: Static data members are NOT counted with the <tt><b>sizeof</b></tt> operator. Only
non-static data is included. This is true when using <tt><b>sizeof</b></tt> with either the class
itself, or objects of the class.
</p>
</center>

<p>
Methods can be <tt><b>static</b></tt> as well:
<p>

<table border=0 cellspacing=5 cellpadding=5>
<tr><th>Declarations</th><th>Definitions</th></tr>
<tr valign="top">
<td>
<blockquote><pre>
<b>class</b> String
{
  <b>public</b>:
    <font color="#003399"><i>// Other public members...</i></font>

    <b>static</b> <b>int</b> get_bar(); <font color="#003399"><i>// static</i></font>

  <b>private</b>:
    <b>char</b> *string_;  <font color="#003399"><i>// the &quot;real&quot; string</i></font>
    <b>static</b> <b>int</b> bar; <font color="#003399"><i>// static</i></font>
};
</pre></blockquote>
</td>
<td>
<blockquote><pre>
<font color="#003399"><i>// Initialize outside of class (Definition)</i></font>
<b>int</b> String::bar = 20;

<b>int</b> String::get_bar()
{
  <b>return</b> bar;
}
</pre></blockquote>
</td>
</tr></table>

Sample usage:
<blockquote><pre>
<b>void</b> f8()
{
    <font color="#003399"><i>// Accessing a static member</i></font>
  <b>int</b> i = String::get_bar();

    <font color="#003399"><i>// Error, private now</i></font>
  i = String::bar;
}
</pre></blockquote>

You can access <tt><b>static</b></tt> members through an object as well:
<blockquote><pre>
<b>void</b> f9()
{
  String s1(<font color="#9933CC">&quot;foo&quot;</font>);

  <b>int</b> x = s1.get_bar();      <font color="#003399"><i>// Access through object</i></font>
  <b>int</b> y = String::get_bar(); <font color="#003399"><i>// Access through class</i></font>
}
</pre></blockquote>

<ul>
<li>A static data member is shared between all instances.
<li>You can access static members through an object or the class.
<li>A non-static method can access static data and methods.
<li>A static method can NOT access non-static data and methods (only other static members).
	<ul>
	<li>There is no <b><tt>this</tt></b> pointer with a static method
</ul>
<li>You must <i>define</i> static data outside of the class.
<li>You can initialize <i>constant static integral</i> values within the class:
	
<blockquote><pre>
<b>class</b> String
{
  <b>public</b>:
    <font color="#003399"><i>// Other public members...</i></font>

      <font color="#003399"><i>// can be initialized in the class</i></font>
    <b>const</b> <b>static</b> <b>int</b> foo = 47;
    
  <b>private</b>:
    <font color="#003399"><i>// Other private members...</i></font>
    
      <font color="#003399"><i>// can be initialized in the class</i></font>
    <b>const</b> <b>static</b> <b>char</b> bar = 'B';
};
</pre></blockquote>
	
</ul>

<!-- ************************************************************************************************ -->
<!-- ************************************************************************************************ -->
<p class="SectionHeader">Example
</p>

Suppose we want to keep track of how many String objects were created, how many total bytes were allocated,
and how many Strings are currently active? This is a good candidate for <b>static</b> members. 
<p>
This is what the updated <i>String</i> class looks like:


<blockquote><pre>
<b>class</b> String
{
  <b>public</b>:
    String();                  <font color="#003399"><i>// default constructor</i></font>
    String(<b>const</b> String&amp; rhs); <font color="#003399"><i>// copy constructor</i></font>
    String(<b>const</b> <b>char</b> *cstr);  <font color="#003399"><i>// conversion constructor</i></font>
    ~String();                 <font color="#003399"><i>// destructor</i></font>

      <font color="#003399"><i>// Copy assignment operator</i></font>
    String&amp; <b>operator</b>=(<b>const</b> String&amp; rhs); 

    <font color="blue"><b>static</b> <b>int</b> created_;</font>    <font color="#003399"><i>// Total number of Strings constructed</i></font>
    <font color="blue"><b>static</b> <b>int</b> alive_;</font>      <font color="#003399"><i>// Total number of Strings still around</i></font>
    <font color="blue"><b>static</b> <b>int</b> bytes_used_;</font> <font color="#003399"><i>// Total bytes allocated for all Strings</i></font>

    <font color="#003399"><i>// Other public members</i></font>

  <b>private</b>:
    <b>char</b> *string_;  <font color="#003399"><i>// the &quot;real&quot; string</i></font>

    <font color="#003399"><i>// Other private members</i></font>
};
</pre></blockquote>

In <tt><b>String.cpp</b></tt>

<blockquote><pre>
<font color="#003399"><i>// Define and initialize the static members</i></font>  
<b>int</b> String::bytes_used_ = 0;
<b>int</b> String::created_ = 0;
<b>int</b> String::alive_ = 0;
</pre></blockquote>

Updated member functions:

<blockquote>
<table border=0 cellspacing=5 cellpadding=5>
<tr><th>Default constructor</th><th>&nbsp;&nbsp;&nbsp;&nbsp;</th><th>Conversion Constructor</th></tr>

<tr valign="top">
<td>
<pre>
String::String()
{
    <font color="#003399"><i>// Allocate minimal space</i></font>
  string_ = <b>new</b> <b>char</b>[1]; 
  string_[0] = 0;     

  bytes_used_ += 1;
  created_++;
  alive_++;

  <font color="990099">#ifdef PRINT</font>
  std::cout &lt;&lt; <font color="#9933CC">&quot;Default constructor&quot;</font> &lt;&lt; std::endl;
  <font color="990099">#endif</font>
}
</pre>
</td>

<td></td>

<td>
<pre>
String::String(<b>const</b> <b>char</b> *cstr)
{
    <font color="#003399"><i>// Allocate space and copy</i></font>
  <b>int</b> len = (<b>int</b>)strlen(cstr);
  string_ = <b>new</b> <b>char</b>[len + 1];
  std::strcpy(string_, cstr);      

  bytes_used_ += len + 1;
  created_++;
  alive_++;

  <font color="990099">#ifdef PRINT</font>
  std::cout &lt;&lt; <font color="#9933CC">&quot;Conversion constructor: &quot;</font> &lt;&lt; cstr &lt;&lt; std::endl;
  <font color="990099">#endif</font>
}
</pre>
</td>
</tr>

<tr><th>Destructor</th><th></th><th>Copy Constructor</th></tr>
<tr valign="top">
<td>
<pre>
String::~String()
{
  <font color="990099">#ifdef PRINT</font>
  std::cout &lt;&lt; <font color="#9933CC">&quot;Destructor: &quot;</font> &lt;&lt; string_  &lt;&lt; std::endl;
  <font color="990099">#endif</font>

  <b>delete</b> [] string_; <font color="#003399"><i>// release the memory</i></font>
  
  alive_--;
}
</pre>
</td>

<td></td>

<td>
<pre>
String::String(<b>const</b> String&amp; rhs)
{
  <b>int</b> len = (<b>int</b>)strlen(rhs.string_);
  string_ = <b>new</b> <b>char</b>[len + 1];
  std::strcpy(string_, rhs.string_);

  bytes_used_ += len + 1;
  created_++;
  alive_++;

  <font color="990099">#ifdef PRINT</font>
  std::cout &lt;&lt; <font color="#9933CC">&quot;Copy constructor: &quot;</font> &lt;&lt; rhs.string_ &lt;&lt; std::endl;
  <font color="990099">#endif</font>
}
</pre>
</td>
</tr>
</table>


<table border=0 cellspacing=5 cellpadding=5>
<tr><th>Copy assignment operator</th></tr>

<tr valign="top">
<td>
<pre>
String&amp; String::<b>operator</b>=(<b>const</b> String&amp; rhs)
{
  <font color="990099">#ifdef PRINT</font>
  std::cout &lt;&lt; <font color="#9933CC">&quot;operator=: &quot;</font> &lt;&lt; string_ &lt;&lt; <font color="#9933CC">&quot; = &quot;</font> &lt;&lt; rhs.string_ &lt;&lt; std::endl;
  <font color="990099">#endif</font>

  <b>if</b> (&amp;rhs != <b>this</b>)
  {
    <b>delete</b> [] string_;
    <b>int</b> len = (<b>int</b>)strlen(rhs.string_);
    string_ = <b>new</b> <b>char</b>[len + 1];
    std::strcpy(string_, rhs.string_);
  
    bytes_used_ += len + 1;
  }
  <b>return</b> *<b>this</b>;
}
</pre>
</td>
</tr></table>
</blockquote>

Sample test program:

<pre class="sourcecode"><code><font color="990099">#include &lt;iostream&gt; // cout, endl</font>
<font color="990099">#include &quot;String.h&quot; // String class</font>

<font color="#003399"><i>// Print static data</i></font>
<b>void</b> print_stats()
{
  std::cout &lt;&lt; <font color="#9933CC">&quot;Strings created: &quot;</font> &lt;&lt; String::created_ &lt;&lt; <font color="#9933CC">&quot;, &quot;</font>;
  std::cout &lt;&lt; <font color="#9933CC">&quot;Bytes used: &quot;</font> &lt;&lt; String::bytes_used_ &lt;&lt; <font color="#9933CC">&quot;, &quot;</font>;
  std::cout &lt;&lt; <font color="#9933CC">&quot;Strings alive: &quot;</font> &lt;&lt; String::alive_ &lt;&lt; std::endl;
}

<font color="#003399"><i>// Pass a copy, return a copy</i></font>
String pass_by_val(String s)
{
  <b>return</b> s; <font color="#003399"><i>// return a copy</i></font>
}

<font color="#003399"><i>// Pass a reference, return a reference</i></font>
<b>const</b> String&amp; pass_by_ref(<b>const</b> String&amp; s)
{
  <b>return</b> s; <font color="#003399"><i>// return a reference</i></font>
}

<b>void</b> f1()
{
  String s1(<font color="#9933CC">&quot;Hello&quot;</font>);
  print_stats(); <font color="#003399"><i>// Strings created: 1, Bytes used: 6, Strings alive: 1</i></font>

  String s2(s1);
  print_stats(); <font color="#003399"><i>// Strings created: 2, Bytes used: 12, Strings alive: 2</i></font>

  pass_by_val(s1);
  print_stats(); <font color="#003399"><i>// Strings created: 4, Bytes used: 24, Strings alive: 2</i></font>

  pass_by_ref(s1);
  print_stats(); <font color="#003399"><i>// Strings created: 4, Bytes used: 24, Strings alive: 2</i></font>

  s1 = <font color="#9933CC">&quot;Goodbye&quot;</font>;
  print_stats(); <font color="#003399"><i>// Strings created: 5, Bytes used: 40, Strings alive: 2</i></font>

  s2 = s1;
  print_stats(); <font color="#003399"><i>// Strings created: 5, Bytes used: 48, Strings alive: 2</i></font>

  String s3;
  print_stats(); <font color="#003399"><i>// Strings created: 6, Bytes used: 49, Strings alive: 3</i></font>
}

<b>int</b> main()
{
  print_stats(); <font color="#003399"><i>// Strings created: 0, Bytes used: 0, Strings alive: 0</i></font>
  f1();
  print_stats(); <font color="#003399"><i>// Strings created: 6, Bytes used: 49, Strings alive: 0</i></font>
}
</code></pre>

<b>Output:</b> (without <tt>PRINT</tt> defined)

<blockquote><pre>
Strings created: 0, Bytes used: 0, Strings alive: 0
Strings created: 1, Bytes used: 6, Strings alive: 1
Strings created: 2, Bytes used: 12, Strings alive: 2
Strings created: 4, Bytes used: 24, Strings alive: 2
Strings created: 4, Bytes used: 24, Strings alive: 2
Strings created: 5, Bytes used: 40, Strings alive: 2
Strings created: 5, Bytes used: 48, Strings alive: 2
Strings created: 6, Bytes used: 49, Strings alive: 3
Strings created: 6, Bytes used: 49, Strings alive: 0
</pre></blockquote>

<b>Output:</b> (with <tt>PRINT</tt> defined)

<blockquote><pre>
Strings created: 0, Bytes used: 0, Strings alive: 0
Conversion constructor: Hello
Strings created: 1, Bytes used: 6, Strings alive: 1
Copy constructor: Hello
Strings created: 2, Bytes used: 12, Strings alive: 2
Copy constructor: Hello
Copy constructor: Hello
Destructor: Hello
Destructor: Hello
Strings created: 4, Bytes used: 24, Strings alive: 2
Strings created: 4, Bytes used: 24, Strings alive: 2
Conversion constructor: Goodbye
operator=: Hello = Goodbye
Destructor: Goodbye
Strings created: 5, Bytes used: 40, Strings alive: 2
operator=: Hello = Goodbye
Strings created: 5, Bytes used: 48, Strings alive: 2
Default constructor
Strings created: 6, Bytes used: 49, Strings alive: 3
Destructor: 
Destructor: Goodbye
Destructor: Goodbye
Strings created: 6, Bytes used: 49, Strings alive: 0
</pre></blockquote>


<blockquote><pre>
</pre></blockquote>

<blockquote><pre>
</pre></blockquote>

<blockquote><pre>
</pre></blockquote>

<blockquote><pre>
</pre></blockquote>

<blockquote><pre>
</pre></blockquote>

<!--
<table border=0 cellspacing=5 cellpadding=5>
<tr><th>GNU</th><th>Microsoft</th><th>Borland</th></tr>
<tr valign="top">
<td>
<blockquote><pre>
Conversion constructor: foo
0
Destructor: foo
</pre></blockquote>
</td>
<td>
<blockquote><pre>
Conversion constructor: foo
-858993460
Destructor: foo
</pre></blockquote>
</td>
<td>
<blockquote><pre>
Conversion constructor: foo
4462868
Destructor: foo
</pre></blockquote>
</td>
</tr></table>
-->


<blockquote><pre>
</pre></blockquote>

<blockquote><pre>
</pre></blockquote>

<blockquote><pre>
</pre></blockquote>

<blockquote><pre>
</pre></blockquote>


<blockquote><pre>
</pre></blockquote>



</body>
</html>

<blockquote><pre>
</pre></blockquote>




<blockquote>
<table border=0 cellspacing=5 cellpadding=0>
<tr><th></th><th></th><th></th></tr>
<tr valign="top">
<td>
<blockquote><pre>
</pre></blockquote>
</td>
<td>
<blockquote><pre>
</pre></blockquote>
</td>
<td>
<blockquote><pre>
</pre></blockquote>
</td>
</tr></table>
</blockquote>

<tt><b></b></tt>

<blockquote>
<table border=0 cellspacing=5 cellpadding=5>
<tr><th></th><th></th></tr>
<tr valign="top">
<td>
<blockquote><pre>
</pre></blockquote>
</td>
<td>
<blockquote><pre>
</pre></blockquote>
</td>
</tr></table>
</blockquote>

<blockquote><pre>
</pre></blockquote>

</body>
</html>