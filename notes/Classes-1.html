<html>
<head>
	<link rel="stylesheet" type="text/css" href="new.css"> 
	<title>Classes 1</title>
</head>

<body>  
<center><h1>Classes and Objects</h1></center>

<!-- ************************************************************************************************ -->
<!-- ************************************************************************************************ -->
<p class="SectionHeader">Introduction to Object-Oriented Programming
</p>

Procedural programming vs. Object-Oriented programming
<p>
	
Procedural programming:
<ul>
<li>There is a distinct division between code (functions) and data.</li>
<li>Data is passive, it gets acted upon by functions.</li>
<li>We generally pass the data between functions.</li>
<li>The name comes from <i>procedure calls</i>.</li>
<li><i>C</i> is a procedural programming language.</li>
</ul>

Object-Oriented programming:
<ul>
<li>Code and data are encapsulated together in a single <i>object</i>.</li>
<li>The functions that work on the data are part of the object.</li>
<li>We don't have to pass data to the functions.</li>
</ul>

Usually, for a language to be considered object-oriented, it should have these
three properties:

<ol>
<li><b>Encapsulation (data abstraction/hiding)</b></li>
<li>Inheritance (relationships between entities)</li>
<li>Polymorphism (runtime decisions)</li>
</ol>

The topic in <b>bold</b> is what we will be concerned with now.</b>
<p>

In C++, these three properties are realized as:

<ol>
<li>Classes and objects (with access specifiers)</li>
<li>Extending classes with an <i>is-a</i> or <i>is-a-kind-of</i> relationship</li>
<li>Virtual methods and dynamic (runtime) binding</li>
</ol>	


<!-- ************************************************************************************************ -->
<!-- ************************************************************************************************ -->
<p class="SectionHeader">Procedural Programming
</p>

Let's use this structure that represents a student: (What is <b><tt>sizeof</b>(Student)</tt>)?
<p>
Also, notice <tt>MAXLENGTH</tt> is not a <tt><b>#define</b></tt>:

<blockquote>
<table border=0 cellspacing=5 cellpadding=0>
<tr><th></th><th></th></tr>
<tr valign="top">
<td>
<blockquote><pre>
<b>const</b> <b>int</b> MAXLENGTH = 10;

<b>struct</b> Student           
{
  <b>char</b> login[MAXLENGTH];
  <b>int</b> age;
  <b>int</b> year;
  <b>float</b> GPA;
};
</pre></blockquote>
</td>
<td>
<blockquote><pre>
<b>void</b> display_student(<b>const</b> Student &amp;student)
{
  <b>using</b> std::cout;
  <b>using</b> std::endl;

  cout &lt;&lt; <font color="#9933CC">&quot;login: &quot;</font> &lt;&lt; student.login &lt;&lt; endl;
  cout &lt;&lt; <font color="#9933CC">&quot;  age: &quot;</font> &lt;&lt; student.age &lt;&lt; endl;
  cout &lt;&lt; <font color="#9933CC">&quot; year: &quot;</font> &lt;&lt; student.year &lt;&lt; endl;
  cout &lt;&lt; <font color="#9933CC">&quot;  GPA: &quot;</font> &lt;&lt; student.GPA &lt;&lt; endl;
}
</pre></blockquote>
</td>
</tr></table>
</blockquote>

<blockquote><pre>
</pre></blockquote>



<blockquote>
<table border=0 cellspacing=5 cellpadding=5>
<tr><th>This allows this code:</th><th>and this:</th></tr>
<tr valign="top">
<td>
<blockquote><pre>
<b>void</b> f1()
{
  Student st1;

  st1.age = 20;
  st1.GPA = 3.8;
  std::strcpy(st1.login, <font color="#9933CC">&quot;jdoe&quot;</font>);
  st1.year = 3;

  display_student(st1);
}

<b>Output:</b>
login: jdoe
  age: 20
 year: 3
  GPA: 3.8
</pre></blockquote>
</td>
<td>
<blockquote><pre>
<b>void</b> f2()
{
  Student st2;

  st2.age = -5;
  st2.GPA = 12.9;
  std::strcpy(st2.login, <font color="#9933CC">&quot;rumplestiltzkin&quot;</font>);
  st2.year = 150;

  display_student(st2);
}

<b>Output:</b> (May get lucky)
login: rumplestiltzkin
  age: 7235947
 year: 150
  GPA: 12.9
</pre></blockquote>
</td>
</tr></table>
</blockquote>

<blockquote>
<table border=0 cellspacing=5 cellpadding=5>
<tr><th>as well as this:</th></tr>
<tr valign="top">
<td>
<blockquote><pre>
<b>void</b> f1()
{
  Student st3;

  display_student(st3);
}

<b>Output:</b>
login: |
  age: 0
 year: 4198736
  GPA: 2.07362e-317
</pre></blockquote>
</td>
</tr></table>
</blockquote>



A second attempt to "protect" the data by using functions to set the data instead of the user
<i>directly</i> modifying it.

<blockquote><pre>
<b>void</b> set_login(Student &amp;student, <b>const</b> <b>char</b>* login);
<b>void</b> set_age(Student &amp;student, <b>int</b> age);
<b>void</b> set_year(Student &amp;student, <b>int</b> year);
<b>void</b> set_GPA(Student &amp;student, <b>float</b> GPA);
</pre></blockquote>


<blockquote>
<table border=0 cellspacing=5 cellpadding=0>
<tr><th></th><th></th></tr>
<tr valign="top">
<td>
<blockquote><pre>
<b>void</b> set_login(Student &amp;student, <b>const</b> <b>char</b>* login)
{
  std::<a href="http://www.cplusplus.com/reference/cstring/strncpy/?kw=strncpy">strncpy</a>(student.login, login, MAXLENGTH);
  student.login[MAXLENGTH - 1] = 0;
}
</pre></blockquote>
</td>
<td>
<blockquote><pre>
<b>void</b> set_age(Student &amp;student, <b>int</b> age)
{
  <b>if</b> ( (age &lt; 18) || (age &gt; 100) )
  {
    std::cout &lt;&lt; <font color="#9933CC">&quot;Error in age range!\n&quot;</font>;
    student.age = 18;
  }
  <b>else</b>
    student.age = age;
}
</pre></blockquote>
</td>
</tr></table>
</blockquote>

<blockquote>
<table border=0 cellspacing=5 cellpadding=0>
<tr><th></th><th></th></tr>
<tr valign="top">
<td>
<blockquote><pre>
<b>void</b> set_year(Student &amp;student, <b>int</b> year)
{
  <b>if</b> ( (year &lt; 1) || (year &gt; 4) )
  {
    std::cout &lt;&lt; <font color="#9933CC">&quot;Error in year range!\n&quot;</font>;
    student.year = 1;
  }
  <b>else</b>
    student.year = year;
}
</pre></blockquote>
</td>
<td>
<blockquote><pre>
<b>void</b> set_GPA(Student &amp;student, <b>float</b> GPA)
{
  <b>if</b> ( (GPA &lt; 0.0) || (GPA &gt; 4.0) )
  {
    std::cout &lt;&lt; <font color="#9933CC">&quot;Error in GPA range!\n&quot;</font>;
    student.GPA = 0.0;
  }
  <b>else</b>
    student.GPA = GPA;
}
</pre></blockquote>
</td>
</tr></table>
</blockquote>


<blockquote>
<table border=0 cellspacing=5 cellpadding=0>
<tr><th>Now this code:</th><th>results in this:</th></tr>
<tr valign="top">
<td>
<blockquote><pre>
<b>void</b> f3()
{
  Student st3;

  set_age(st3, -5);
  set_GPA(st3, 12.9);
  set_login(st3, <font color="#9933CC">&quot;rumplestiltzkin&quot;</font>);
  set_year(st3, 150);

  display_student(st3);
}
</pre></blockquote>
</td>
<td>
<blockquote><pre>
Error in age range!
Error in GPA range!
Error in year range!
login: rumplesti
  age: 18
 year: 1
  GPA: 0
</pre></blockquote>
</td>
</tr></table>
</blockquote>

Notes:
<ul>
<li>It may not be perfect yet, but at least we can try to prevent memory corruption.
<li>There is still nothing preventing the user (programmer) from accessing the fields directly.
<li>We can "hide" (<i>encapsulate</i>) the data fields by using the <tt><b>private</b></tt> access specifier:

<blockquote><pre>
<b>struct</b> Student           
{
    <font color="#003399"><i>// All data is inaccessible from outside this structure</i></font>
  <b>private</b>:
    <b>char</b> login[MAXLENGTH];
    <b>int</b> age;
    <b>int</b> year;
    <b>float</b> GPA;
};
</pre></blockquote>


This code will give errors now:


<blockquote>
<table border=0 cellspacing=5 cellpadding=0>
<tr><th>Illegal code:</th><th>Errors:</th></tr>
<tr valign="top">
<td>
<blockquote><pre>
Student st1;

st1.age = 20;
st1.GPA = 3.8;
std::strcpy(st1.login, <font color="#9933CC">&quot;jdoe&quot;</font>);
st1.year = 3;
</pre></blockquote>
</td>
<td>
<blockquote><pre>
error: `int Student::age' is private
error: within this context
error: `float Student::GPA' is private
error: within this context
error: `char Student::login[10]' is private
error: within this context
error: `int Student::year' is private
error: within this context
</pre></blockquote>
</td>
</tr></table>
</blockquote>

However, even this code will no longer work:

<blockquote><pre>
<b>void</b> set_age(Student &amp;student, <b>int</b> age)
{
  <b>if</b> ( (age &lt; 18) || (age &gt; 100) )
  {
    std::cout &lt;&lt; <font color="#9933CC">&quot;Error in age range!\n&quot;</font>;
    student.age = 18;  <font color="#003399"><i>// ERROR, age is private</i></font>
  }
  <b>else</b>
    student.age = age; <font color="#003399"><i>// ERROR, age is private</i></font>
}
</pre></blockquote>

</ul>

The solution? Put the functions <i>inside</i> the Student <tt><b>struct</b></tt> along with the data. This is
	<i>encapsulation</i>. 
	
<blockquote>
<p class="technote">
In C++, encapsulated functions are generally called <i>methods</i> or <i>member functions</i>
(because they are <i>members</i> of the structure).
</p>
</blockquote>
	

<!-- ************************************************************************************************ -->
<!-- ************************************************************************************************ -->
<p class="SectionHeader">Encapsulating Functions and Data
</p>

Adding functions to the structure is simple. By declaring them in a <tt><b>public</b></tt> section, the
functions (methods) will be accessible from outside of the structure:

<p>
		
<table border=0 cellspacing=5 cellpadding=0>
<tr><th>Structure with private data, public methods</th><th width="30"></th><th>Client access is through the public methods</th></tr>
<tr valign="top">
<td>
<blockquote><pre>
<font color="#003399"><i>// This code is in a header (.h) file </i></font>  
<b>const</b> <b>int</b> MAXLENGTH = 10;

<b>struct</b> Student           
{
  <b>public</b>:
    <b>void</b> set_login(<b>const</b> <b>char</b>* login);
    <b>void</b> set_age(<b>int</b> age);
    <b>void</b> set_year(<b>int</b> year);
    <b>void</b> set_GPA(<b>float</b> GPA);

  <b>private</b>:
    <b>char</b> login_[MAXLENGTH];
    <b>int</b> age_;
    <b>int</b> year_;
    <b>float</b> GPA_;
};
</pre></blockquote>
</td>
<td width="30">
</td>
<td>
<blockquote><pre><b>void</b> f1()
{
    <font color="#003399"><i>// Create a Student struct (object)</i></font>
  Student st1;

    <font color="#003399"><i>// Set the fields using the public methods</i></font>
  st1.set_login(<font color="#9933CC">&quot;jdoe&quot;</font>);
  st1.set_age(22);
  st1.set_year(4);
  st1.set_GPA(3.8);

  st1.age_ = 10; <font color="#003399"><i>// ERROR, private</i></font>
  st1.year_ = 2; <font color="#003399"><i>// ERROR, private</i></font>
}
</pre></blockquote>
</td>
</tr></table>
</blockquote>
	
The implementation of the methods will change slightly:

<p>
<table border=0 cellspacing=0 cellpadding=0>
<tr><th></th><th></th></tr>
<tr valign="top">
<td>
<blockquote><pre>
<font color="#003399"><i>// This code is in a .cpp file </i></font>  

<b>void</b> Student::set_login(<b>const</b> <b>char</b>* login)
{
  std::strncpy(login_, login, MAXLENGTH);
  login_[MAXLENGTH - 1] = 0;
}
</pre></blockquote>
</td>
<td>
<blockquote><pre>


<b>void</b> Student::set_age(<b>int</b> age)
{
  <b>if</b> ( (age &lt; 18) || (age &gt; 100) )
  {
    std::cout &lt;&lt; <font color="#9933CC">&quot;Error in age range!\n&quot;</font>;
    age_ = 18;
  }
  <b>else</b>
    age_ = age;
}
</pre></blockquote>
</td>
</tr></table>


<table border=0 cellspacing=5 cellpadding=0>
<tr><th></th><th></th></tr>
<tr valign="top">
<td>
<blockquote><pre>
<b>void</b> Student::set_year(<b>int</b> year)
{
  <b>if</b> ( (year &lt; 1) || (year &gt; 4) )
  {
    std::cout &lt;&lt; <font color="#9933CC">&quot;Error in year range!\n&quot;</font>;
    year_ = 1;
  }
  <b>else</b>
    year_ = year;
}
</pre></blockquote>
</td>
<td>
<blockquote><pre>
<b>void</b> Student::set_GPA(<b>float</b> GPA)
{
  <b>if</b> ( (GPA &lt; 0.0) || (GPA &gt; 4.0) )
  {
    std::cout &lt;&lt; <font color="#9933CC">&quot;Error in GPA range!\n&quot;</font>;
    GPA_ = 0.0;
  }
  <b>else</b>
    GPA_ = GPA;
}
</pre></blockquote>
</td>
</tr></table>


You'll notice a few things about these implementations:
<ul>
<li>We no longer need to pass a reference to the Student to the method. (The methods "know" which object they are accessing.)
<li>This means we don't have to use the structure dot operator (i.e. <tt>age_</tt> instead of <tt>st1.age_</tt>)
<li>We need to indicate that the method belongs to the Student structure by using the scope resolution operator:
<p>
<table border=0 cellspacing=5 cellpadding=0>
<tr><th></th><th></th></tr>
<tr valign="top">
<td>
<blockquote><pre>
<font color="#003399"><i>// This method belongs to the Student struct</i></font>
<b>void</b> <font color="blue"><b>Student::</b></font>set_year(<b>int</b> year)
{
  <b>if</b> ( (year &lt; 1) || (year &gt; 4) )
  {
    std::cout &lt;&lt; <font color="#9933CC">&quot;Error in year range!\n&quot;</font>;
    year_ = 1;
  }
  <b>else</b>
    year_ = year;
}
</pre></blockquote>
</td>
<td>
<blockquote><pre>
<font color="#003399"><i>// This is a &quot;normal&quot; global function</i></font>
<font color="#003399"><i>// not part of any struct</i></font>
<b>void</b> set_year(<b>int</b> year)
{
  <font color="#003399"><i>// body of function</i></font>
}

</pre></blockquote>
</td>
</tr></table>

</ul>

Incidentally, the default access for a <tt><b>struct</b></tt> is public. (This is for C compatibility.) These two structures
are identical:

<blockquote>
<table border=0 cellspacing=5 cellpadding=5>
<tr><th>Members are public by default</th><th>OK, but redundant</th></tr>
<tr valign="top">
<td>
<blockquote><pre>
<b>struct</b> Student
{
  <b>char</b> login_[MAXLENGTH];
  <b>int</b> age_;
  <b>int</b> year_;
  <b>float</b> GPA_;
};
</pre></blockquote>
</td>
<td>
<blockquote><pre>
<b>struct</b> Student
{
  <b>public</b>:
    <b>char</b> login_[MAXLENGTH];
    <b>int</b> age_;
    <b>int</b> year_;
    <b>float</b> GPA_;
};
</pre></blockquote>
</td>
</tr></table>
</blockquote>

You generally won't see the <tt><b>public</b></tt> keyword used with structures.
<p>
Finally, we need to get back a way to display the values. Our original <i>display_student</i> no longer can
access the private members, so we have to make it part of the <i>Student</i> structure:

<blockquote>
<table border=0 cellspacing=5 cellpadding=0>
<tr><th>Add the <tt>display</tt> method</th><th>Modify the implementation</th></tr>
<tr valign="top">
<td>
<blockquote><pre>
<b>struct</b> Student           
{
  <b>public</b>:
    <b>void</b> set_login(<b>const</b> <b>char</b>* login);
    <b>void</b> set_age(<b>int</b> age);
    <b>void</b> set_year(<b>int</b> year);
    <b>void</b> set_GPA(<b>float</b> GPA);
    <font color="blue"><b>void</b> display();</font>

  <b>private</b>:
    <b>char</b> login_[MAXLENGTH];
    <b>int</b> age_;
    <b>int</b> year_;
    <b>float</b> GPA_;
};
</pre></blockquote>
</td>
<td>
<blockquote><pre>
<b>void</b> <font color="blue">Student::</font>display(<!--<font color="blue"><b>void</b></font>-->)
{
  <b>using</b> std::cout;
  <b>using</b> std::endl;

  cout &lt;&lt; <font color="#9933CC">&quot;login: &quot;</font> &lt;&lt; <font color="blue">login_</font> &lt;&lt; endl;
  cout &lt;&lt; <font color="#9933CC">&quot;  age: &quot;</font> &lt;&lt; <font color="blue">age_</font> &lt;&lt; endl;
  cout &lt;&lt; <font color="#9933CC">&quot; year: &quot;</font> &lt;&lt; <font color="blue">year_</font> &lt;&lt; endl;
  cout &lt;&lt; <font color="#9933CC">&quot;  GPA: &quot;</font> &lt;&lt; <font color="blue">GPA_</font> &lt;&lt; endl;
}
</pre></blockquote>
</td>
</tr></table>
</blockquote>


Now, this is how we use it:

<blockquote><pre>
<b>void</b> f1()
{
    <font color="#003399"><i>// Create a Student object</i></font>
  Student st1;

    <font color="#003399"><i>// Using the public methods</i></font>
  st1.set_login(<font color="#9933CC">&quot;jdoe&quot;</font>);
  st1.set_age(22);
  st1.set_year(4);
  st1.set_GPA(3.8);

    <font color="#003399"><i>// Tell the object to display itself</i></font>
  st1.display();  
}
</pre></blockquote>

<ul>
  <li>Now that the data in the structure is private, the user can't "screw" it up by assigning
    arbitrary values.</li>
  <li>This is one of the major reasons for "hiding" (<i>encapsulating</i>) the data.</li> 
  <li>There are still many problems with the code and we will address those in time. Here's 
    a peek at one of the problems that still exists:
    <blockquote><pre>
Student st1;   <font color="#003399"><i>// Create a Student</i></font>
st1.display(); <font color="#003399"><i>// Undefined behavior!</i></font>
    </pre></blockquote>

  </li>
</ul>


<!-- ************************************************************************************************ -->
<!-- ************************************************************************************************ -->
<p class="SectionHeader">Classes
</p>

In short, a <b>class</b> is identical to a <b>struct</b> with one <!--(almost)--> exception: the default accessibility
is <b>private</b>. 
<p>
	
These will work the same:

<blockquote>
<table border=0 cellspacing=5 cellpadding=0>
<tr><th>Default for struct is public</th><th>Explicit public keyword</th></tr>
<tr valign="top">
<td>
<blockquote><pre>
<font color="blue"><b>struct</b></font> Student
{
  <b>char</b> login_[MAXLENGTH];
  <b>int</b> age_;
  <b>int</b> year_;
  <b>float</b> GPA_;
};
</pre></blockquote>
</td>
<td>
<blockquote><pre>
<font color="blue"><b>class</b></font> Student
{
  <b>public</b>:
    <b>char</b> login_[MAXLENGTH];
    <b>int</b> age_;
    <b>int</b> year_;
    <b>float</b> GPA_;
};
</pre></blockquote>
</td>
</tr></table>
</blockquote>

And these will work the same:

<blockquote>
<table border=0 cellspacing=5 cellpadding=0>
<tr><th>Explicitly private</th><th>Default for class is private</th></tr>
<tr valign="top">
<td>
<blockquote><pre>
<font color="blue"><b>struct</b></font> Student
{
  <b>private</b>:
    <b>char</b> login_[MAXLENGTH];
    <b>int</b> age_;
    <b>int</b> year_;
    <b>float</b> GPA_;
};
</pre></blockquote>
</td>
<td>
<blockquote><pre>
<font color="blue"><b>class</b></font> Student
{
  <b>char</b> login_[MAXLENGTH];
  <b>int</b> age_;
  <b>int</b> year_;
  <b>float</b> GPA_;
};
</pre></blockquote>
</td>
</tr></table>
</blockquote>

<!--
So why have both <tt><b>struct</b></tt> and <tt><b>class</b></tt>? Here's what 
<a href="http://cpptips.hyperformix.com/cpptips/struct_vs_class.txt">the C++'s inventor says</a>. 
-->

<p>
We will generally be using the <tt><b>class</b></tt> keyword when creating new types that have methods associated
with them. We'll use the <tt><b>struct</b></tt> keyword for POD types. (<b>P</b>lain <b>O</b>ld <b>D</b>ata types).
<p>
If you think a little more in-depth about what a data-type is, you'll see it's more than just the range of values.
It is also the <i>operations</i> that can be performed on it. (e.g. you can't use the mod operator, <tt>%</tt>, with
floating point values nor can you use the <tt>+</tt> operator with two pointers.)


<!-- ************************************************************************************************ -->
<!-- ************************************************************************************************ -->
<p class="SectionHeader">Initializing Objects: The Constructor
</p>

This is the problem we need to solve:

<blockquote>
<table border=0 cellspacing=5 cellpadding=5>
<tr><th>Client code</th><th>Output (random garbage, might crash)</th></tr>
<tr valign="top">
<td>
<blockquote><pre>
Student s;   <font color="#003399"><i>// Uninitialized student</i></font>
s.display(); <font color="#003399"><i>// ???</i></font>
</pre></blockquote>
</td>
<td>
<blockquote><pre>
login:  PA
  age: 4280352
 year: 4225049
  GPA: 1.89223e-307
</pre></blockquote>
</td>
</tr></table>
</blockquote>

We never want to have any objects that are in an <i>undefined</i> state. <i>Ever</i>.
 <p>
Recall how we initialize structures:

<blockquote>
<table border=0 cellspacing=5 cellpadding=0>
<tr><th></th><th></th></tr>
<tr valign="top">
<td>
<blockquote><pre>
<b>struct</b> Student           
{
    <font color="#003399"><i>// Public by default</i></font>
  <b>char</b> login[MAXLENGTH];
  <b>int</b> age;
  <b>int</b> year;
  <b>float</b> GPA;
};
</pre></blockquote>
</td>
<td>
<blockquote><pre>
<b>void</b> f()
{
    <font color="#003399"><i>// Uninitialized Student</i></font>
  Student st1;

    <font color="#003399"><i>// Set values by <b>assignment</b></i></font>
  std::strcpy(st1.login, <font color="#9933CC">&quot;jdoe&quot;</font>);
  st1.age = 20;
  st1.year = 3;
  st1.GPA = 3.08;

    <font color="#003399"><i>// Set values by <b>initialization</b></i></font>
  Student john = {<font color="#9933CC">&quot;jdoe&quot;</font>, 20, 3, 3.10f};
  Student jane = {<font color="#9933CC">&quot;jsmith&quot;</font>, 19, 2, 3.95f};
}
</pre></blockquote>
</td>
</tr></table>
</blockquote>


But with private data, using the initializer list is illegal:

<blockquote>
<table border=0 cellspacing=5 cellpadding=0>
<tr><th></th><th></th></tr>
<tr valign="top">
<td>
<blockquote><pre>
<b>class</b> Student           
{
    <font color="#003399"><i>// Private by default</i></font>
  <b>char</b> login[MAXLENGTH];
  <b>int</b> age;
  <b>int</b> year;
  <b>float</b> GPA;
};
</pre></blockquote>
</td>
<td>
<blockquote><pre>
<b>void</b> f()
{
    <font color="#003399"><i>// This is now illegal (accessing private members directly)</i></font>
  Student john = {<font color="#9933CC">&quot;jdoe&quot;</font>, 20, 3, 3.10f};
  Student jane = {<font color="#9933CC">&quot;jsmith&quot;</font>, 19, 2, 3.95f};
}
</pre></blockquote>
</td>
</tr></table>
</blockquote>

You'll get errors like these:
<p>
	
GNU:
<blockquote><pre>
error: 'john' must be initialized by constructor, not by '{...}'
error: 'jane' must be initialized by constructor, not by '{...}'
</pre></blockquote>

Microsoft:
<blockquote><pre>
main1.cpp(116) : error C2552: 'john' : non-aggregates cannot be initialized with initializer list
        'Student' : Types with private or protected data members are not aggregate
main1.cpp(117) : error C2552: 'jane' : non-aggregates cannot be initialized with initializer list
        'Student' : Types with private or protected data members are not aggregate
</pre></blockquote>

Clang:
<blockquote><pre>
error: non-aggregate type 'Student' cannot be initialized with an initializer list
  Student john = {"jdoe", 20, 3, 3.10};
          ^      ~~~~~~~~~~~~~~~~~~~~~
error: non-aggregate type 'Student' cannot be initialized with an initializer list
  Student jane = {"jsmith", 19, 2, 3.95};
          ^      ~~~~~~~~~~~~~~~~~~~~~~~
</pre></blockquote>

<!--
Borland:
<blockquote><pre>
Error E2131 main1.cpp 116: Objects of type 'Student' cannot be initialized with { } in function f()
</pre></blockquote>
-->

The error message from GNU indicates what you need to do: <i>initialize by constructor</i>.
<p>

So, we declare another method that will be called to <i>construct</i> (initialize) the object: (notice the order of <tt><b>public</b></tt> and <tt><b>private</b></tt>, the order is arbitrary)

<blockquote><pre>
<b>class</b> Student           
{
  <b>public</b>:
      <font color="#003399"><i>// Constructor (<b>must</b> have the same name as the class)</i></font>
    <font color="blue">Student(<b>const</b> <b>char</b> * login, <b>int</b> age, <b>int</b> year, <b>float</b> GPA);</font>

    <b>void</b> set_login(<b>const</b> <b>char</b>* login);
    <b>void</b> set_age(<b>int</b> age);
    <b>void</b> set_year(<b>int</b> year);
    <b>void</b> set_GPA(<b>float</b> GPA);
    <b>void</b> display();

  <b>private</b>:
    <b>char</b> login_[MAXLENGTH];
    <b>int</b> age_;
    <b>int</b> year_;
    <b>float</b> GPA_;
};
</pre></blockquote>

We can easily implement this method by simply calling the other methods:
<p>
<table border=0 cellspacing=5 cellpadding=5>
<tr><th>Implementation</th><th>Client can initialize now</th></tr>
<tr valign="top">
<td>
<blockquote><pre>
Student::Student(<b>const</b> <b>char</b> * login, <b>int</b> age, 
                 <b>int</b> year, <b>float</b> GPA)
{
  set_login(login);
  set_age(age);
  set_year(year);
  set_GPA(GPA);
}
</pre></blockquote>
</td>
<td>
<blockquote><pre>
<b>void</b> f()
{
    <font color="#003399"><i>// Set values by <b>constructor</b></i></font>
  Student john(<font color="#9933CC">&quot;jdoe&quot;</font>, 20, 3, 3.10f);
  Student jane(<font color="#9933CC">&quot;jsmith&quot;</font>, 19, 2, 3.95f);
}
</pre></blockquote>
</td>
</tr></table>

Notes:
<ul>
<li>The constructor solves the initialization problem.
<li>The initialization seems almost automatic.
<li>It also prevents any Student structs from ever being uninitialized. This is a very important and powerful feature.
<li>C++11 allows <i>brace-initialization</i> using <i>uniform initialization syntax</i>:
<blockquote><pre>
<b>void</b> f()
{
    <font color="#003399"><i>// Set values by <b>constructor</b> (Still requires a constructor)</i></font>
  Student john {<font color="#9933CC">&quot;jdoe&quot;</font>, 20, 3, 3.10f};
  Student jane {<font color="#9933CC">&quot;jsmith&quot;</font>, 19, 2, 3.95f};
}
</pre></blockquote>

More on this and other initialization techniques later.</li>
</ul>

	

<!-- ************************************************************************************************ -->
<!-- ************************************************************************************************ -->
<p class="SectionHeader">Accessors and Mutators (Gettors and Settors)
</p>

Since the data in a class is usually <tt><b>private</b></tt>, the only way to gain access to it is by
providing <tt><b>public</b></tt> methods that explicitly allow it.

<ul>
<li>A method that allows you to <i>read</i> a private value is called an <i>accessor method</i>. (Also called a <i>gettor method</i> because you <i>get</i> the value.)
<li>A method that allows you to <i>write</i> (change) a private value is called a <i>mutator method</i>. (Also called a <i>settor method</i> because you <i>set</i> the value.);
<li>A class may provide one, both, or none of these method types.
	<ul>
<li>If only an accessor is provided for a private data member, the data is considered <i>read-only</i>
<li>If only a mutator is provided for a private data member, the data is considered <i>write-only</i>
<li>If both methods are provided for a private data member, the data is considered <i>read-write</i>
</ul>
</ul>

All of the data in the Student class is write-only, since we can change it, but we can't read it.
<p>

<table border=0 cellspacing=5 cellpadding=5>
<tr><th>Adding accessors</th><th>Implementations</th></tr>
<tr valign="top">
<td>
<blockquote><pre>
<b>struct</b> Student           
{
  <b>public</b>:
      <font color="#003399"><i>// Constructor</i></font>
    Student(<b>const</b> <b>char</b> * login, <b>int</b> age, 
            <b>int</b> year, <b>float</b> GPA);

      <font color="#003399"><i>// Accessors (gettors)</i></font>
    <font color="blue"><b>int</b> get_age();
    <b>int</b> get_year();
    <b>float</b> get_GPA();
    <b>const</b> <b>char</b> *get_login(); </font>
    
      <font color="#003399"><i>// Mutators (settors)</i></font>
    <b>void</b> set_login(<b>const</b> <b>char</b>* login);
    <b>void</b> set_age(<b>int</b> age);
    <b>void</b> set_year(<b>int</b> year);
    <b>void</b> set_GPA(<b>float</b> GPA);

    <b>void</b> display();

  <b>private</b>:
    <b>char</b> login_[MAXLENGTH];
    <b>int</b> age_;
    <b>int</b> year_;
    <b>float</b> GPA_;
};
</pre></blockquote>
</td>
<td>
<blockquote><pre>
<b>int</b> Student::get_age()
{
  <b>return</b> age_;
}

<b>int</b> Student::get_year()
{
  <b>return</b> year_;
}

<b>float</b> Student::get_GPA()
{
  <b>return</b> GPA_;
}

<b>const</b> <b>char</b> *Student::get_login()
{
  <b>return</b> login_;
}
</pre></blockquote>
</td>
</tr></table>

Providing (or not providing) accessors and mutators is how you control access and modifications to
the private data. What if you didn't want to allow the client to change the login?

<!--
Remove the set_login method or make it private. Now, the login is set through the constructor
and can never change.
-->
<!-- ************************************************************************************************ -->
<!-- ************************************************************************************************ -->
<p class="SectionHeader">Resource Management
</p>

The Student class so far:
<ul>
	<li>All Student objects are initialzed.
	<li>Can't corrupt private data. (Public methods validate)
	<li>Login name is limited to 10 chars and can be truncated. (Safe, but not ideal)
</ul>

We need to change the login so its length is determined <i>at run-time</i> (read: dynamically). By the way, what is <tt><b>sizeof</b></tt>(<tt><b>struct</b></tt> Student) now?
<p>
	
<table border=0 cellspacing=5 cellpadding=5>
<tr><th>Change type of <tt>login_</tt></th><th>Implementation change (not 100% correct yet, has at least 2 potential bugs!)</th></tr>
<tr valign="top">
<td>
<blockquote><pre>
<b>struct</b> Student
{
  <b>public</b>:
      <font color="#003399"><i>// Public interface ...</i></font>
  <b>private</b>:
    <font color="blue"><b>char</b> *login_; </font>
    <b>int</b> age_;
    <b>int</b> year_;
    <b>float</b> GPA_;
};
</pre></blockquote>
</td>
<td>
<blockquote><pre>
<b>void</b> Student::set_login(<b>const</b> <b>char</b>* login)
{
  <b>int</b> len = (<b>int</b>)std::strlen(login);
  login_ = <b>new</b> <b>char</b>[len + 1];  <font color="#003399"><i>// Don't forget the NUL character!</i></font>
  std::strcpy(login_, login);
}
</pre></blockquote>
</td>
</tr></table>

<p>
	
The client doesn't even know there has been a change:

<blockquote><pre>
<b>void</b> foo()
{
    <font color="#003399"><i>// Construct a Student object</i></font>
  Student john(<font color="#9933CC">&quot;rumplestiltzkin&quot;</font>, 20, 3, 3.10f);

    <font color="#003399"><i>// This will display all of the data</i></font>
  john.display();
}
</pre></blockquote>

That is the only change required (sort of). What is the problem?
<p>
How about this?

<blockquote><pre>
john.set_login(<font color="#9933CC">&quot;johnny&quot;</font>);
john.set_login(<font color="#9933CC">&quot;jj&quot;</font>);
john.set_login(<font color="#9933CC">&quot;doofus&quot;</font>);
</pre></blockquote>

<br><br><br><br>

<!--
Actually, two problems.
1. When the object goes out of scope, the login is not freed.
2. If the user changes the login, a new buffer is allocated but
   the old one is not freed.
-->

<table border=0 cellspacing=5 cellpadding=5>
<tr><th>Add interface method</th><th>Add implementation</th></tr>
<tr valign="top">
<td>
<blockquote><pre>
<b>struct</b> Student
{
  <b>public</b>:
    <font color="#003399"><i>// Public stuff ...</i></font>
    <b>void</b> free_login();
  <b>private</b>:
    <font color="#003399"><i>// Private stuff ...</i></font>
};
</pre></blockquote>
</td>
<td>
<blockquote><pre>
<b>void</b> Student::free_login()
{
  <b>delete</b> [] login_; <font color="#003399"><i>// It's an array, requires []</i></font>
}
</pre></blockquote>
</td>
</tr></table>


Now, the client will do this:

<blockquote><pre>
<b>void</b> foo()
{
    <font color="#003399"><i>// Construct a Student object</i></font>
  Student john(<font color="#9933CC">&quot;jdoe&quot;</font>, 20, 3, 3.10f);

    <font color="#003399"><i>// This will display all of the data</i></font>
  john.display();

    <font color="#003399"><i>// Release the memory for login_</i></font>
  john.free_login();
}
</pre></blockquote>

But this is wrong on so many levels... Here are two of them:

<p>

<table border=0 cellspacing=5 cellpadding=5>
<tr><th></th><th></th></tr>
<tr valign="top">
<td>
<blockquote><pre>
<b>void</b> foo()
{
    <font color="#003399"><i>// Construct a Student object</i></font>
  Student john(<font color="#9933CC">&quot;jdoe&quot;</font>, 20, 3, 3.10f);

    <font color="#003399"><i>// This will display all of the data</i></font>
  john.display();
  
    <font color="#003399"><i>// Oops, memory leak now!</i></font>
}
</pre></blockquote>
</td>
<td>
<blockquote><pre>
<b>void</b> foo()
{
    <font color="#003399"><i>// Construct a Student object</i></font>
  Student john(<font color="#9933CC">&quot;jdoe&quot;</font>, 20, 3, 3.10f);

    <font color="#003399"><i>// Release the memory for login_</i></font>
  john.free_login();
  
    <font color="#003399"><i>// Oops, very bad now!</i></font>
  john.display();
}
</pre></blockquote>
</td>
</tr></table>

The Bad News:
<ul>
<li>The client is responsible for the class' private memory.
<li>The client <i>will</i> forget to call the method.
<li>The client <i>will</i> call it and continue to use the object
<li>The client <i>will</i> call it twice (or more).
<li>The client needs to understand about the internal data structures in use.
<li>Probably other reasons...		
</ul>	

Incidentally, if you are going to allow the user to call <tt>set_login</tt>
(maybe repeatedly), then you'll
need to modify the function slightly:

<table border=0 cellspacing=5 cellpadding=5>
<tr><th>Original method</th><th>Modified (correct, but still has problems) method</th></tr>
<tr valign="top">
<td>
<blockquote><pre>
<b>void</b> Student::set_login(<b>const</b> <b>char</b>* login)
{
  <b>int</b> len = (<b>int</b>)strlen(login);
  login_ = <b>new</b> <b>char</b>[len + 1]; 
  std::strcpy(login_, login);
}
</pre></blockquote>
</td>
<td>
<blockquote><pre>
<b>void</b> Student::set_login(<b>const</b> <b>char</b>* login)
{
    <font color="#003399"><i>// Free the "old" login</i></font>
  <b>delete</b> [] login_;

    <font color="#003399"><i>// Now create a new one</i></font>
  <b>int</b> len = (<b>int</b>)strlen(login);
  login_ = <b>new</b> <b>char</b>[len + 1]; 
  std::strcpy(login_, login);
}
</pre></blockquote>
</td>
</tr></table>

<br><br>
You will also need to add this line as the first line in the constructor, to ensure that
it has been initialized. It is safe to delete a NULL pointer.

<blockquote><pre>
login_ = 0;
</pre></blockquote>




In order to make sure that the memory is deleted, we need something like a constructor in reverse. 
Let's call it a <i>destructor</i>.

<!-- ************************************************************************************************ -->
<!-- ************************************************************************************************ -->
<p class="SectionHeader">Destroying Objects: The Destructor
</p>

We'd like some code that will be called when the client is done with the object. The code
is another method called a <i>destructor</i> and is similar to the constructor.
<p>

<table border=0 cellspacing=5 cellpadding=5>
<tr><th>Add destructor</th><th>Add implementation</th></tr>
<tr valign="top">
<td>
<blockquote><pre>
<b>struct</b> Student           
{
  <b>public</b>:
      <font color="#003399"><i>// Constructor</i></font>
    Student(<b>const</b> <b>char</b> * login, <b>int</b> age, <b>int</b> year, <b>float</b> GPA);

      <font color="#003399"><i>// Destructor, same name as constructor, but with a ~ in front</i></font>
      <font color="#003399"><i>// Absolutely no inputs, no return (must match this signature <b>exactly</b>)</i></font>
    <font color="blue">~Student();</font>

    <font color="#003399"><i>// Other public members as before ...</i></font>

  <b>private</b>:
    <font color="#003399"><i>// Private members as before ...</i></font>
};
</pre></blockquote>
</td>
<td>
<blockquote><pre>
Student::~Student()
{
    <font color="#003399"><i>// Free the memory that was allocated</i></font>
  <b>delete</b> [] login_;
}
</pre></blockquote>
</td>
</tr></table>

Now this code is fine:

<blockquote><pre>
<b>void</b> foo()
{
    <font color="#003399"><i>// Construct a Student object</i></font>
  Student john(<font color="#9933CC">&quot;jdoe&quot;</font>, 20, 3, 3.10f);

    <font color="#003399"><i>// This will display all of the data</i></font>
  john.display();
  
} <font color="#003399"><i>// Destructor is called here.</i></font>
</pre></blockquote>

The destructor will be called automagically when the object <i>goes out of scope</i>. (The meaning of scope here 
is the same meaning we've been using since the beginning of C.)
<p>

<blockquote><pre>
<b>void</b> foo()
{
  Student john(<font color="#9933CC">&quot;jdoe&quot;</font>, 20, 3, 3.10f);
  <b>if</b> (john.get_age() &gt; 10)
  {
    Student jane(<font color="#9933CC">&quot;jsmith&quot;</font>, 19, 2, 3.95f);
  } <font color="#003399"><i>// jane's destructor called</i></font>

} <font color="#003399"><i>// john's destructor called</i></font>
</pre></blockquote>

The compiler is smart about calling the destructor for local objects:

<blockquote><pre>
<b>void</b> f7()
{
    <font color="#003399"><i>// Construct a Student object</i></font>
  Student john(<font color="#9933CC">&quot;jdoe&quot;</font>, 20, 3, 3.10f);
  <b>if</b> (john.get_age() &gt; 10)
  {
    Student jane(<font color="#9933CC">&quot;jsmith&quot;</font>, 19, 2, 3.95f);
    <b>if</b> (jane.get_age() &gt; 2)
      <b>return</b>; <font color="#003399"><i>// Destructor's for jane</i></font>
              <font color="#003399"><i>//   and john called</i></font>
  }
}
</pre></blockquote>

This makes the destructor an extremely powerful concept. This is also known as
<i>deterministic destruction</i> because it is guaranteed to work this way every time.

<!-- ************************************************************************************************ -->
<!-- ************************************************************************************************ -->
<p class="SectionHeader">Creating Objects
</p>

Let's modify the constructor and destructor to print a message each time they are called:

<p>
<table border=0 cellspacing=5 cellpadding=5>
<tr><th>Constructor</th><th>Destructor</th></tr>
<tr valign="top">
<td>
<blockquote><pre>
Student::Student(<b>const</b> <b>char</b> * login, <b>int</b> age, 
                 <b>int</b> year, <b>float</b> GPA)
{
  login_ = 0;
  set_login(login);
  set_age(age);
  set_year(year);
  set_GPA(GPA);
  std::cout &lt;&lt; <font color="#9933CC">&quot;Student constructor for &quot;</font> 
            &lt;&lt; login_ &lt;&lt; std::endl;
}
</pre></blockquote>
</td>
<td>
<blockquote><pre>
Student::~Student()
{
  std::cout &lt;&lt; <font color="#9933CC">&quot;Student destructor for &quot;</font> 
            &lt;&lt; login_ &lt;&lt; std::endl;
  <b>delete</b> [] login_;
}
</pre></blockquote>
</td>
</tr></table>

Example:
<p>
<table border=0 cellspacing=5 cellpadding=5>
<tr><th>Program</th><th>Output</th></tr>
<tr valign="top">
<td>
<blockquote><pre>
<b>void</b> foo()
{
  std::cout &lt;&lt; <font color="#9933CC">&quot;***** Begin *****\n&quot;</font>;
  Student john(<font color="#9933CC">&quot;jdoe&quot;</font>, 20, 3, 3.10f);
  Student jane(<font color="#9933CC">&quot;jsmith&quot;</font>, 19, 2, 3.95f);
  Student jim(<font color="#9933CC">&quot;jbob&quot;</font>, 22, 4, 2.76f);

    <font color="#003399"><i>// Modify john</i></font>
  john.set_age(21);
  john.set_GPA(3.25f);

    <font color="#003399"><i>// Modify jane</i></font>
  jane.set_age(24);
  jane.set_GPA(4.0f);

    <font color="#003399"><i>// Modify jim</i></font>
  jim.set_age(23);
  jim.set_GPA(2.98f);

    <font color="#003399"><i>// Display all</i></font>
  john.display(); 
  jane.display();
  jim.display();
  std::cout &lt;&lt; <font color="#9933CC">&quot;***** End *****\n&quot;</font>;
}
</pre></blockquote>
</td>
<td>
<blockquote><pre>
***** Begin *****
Student constructor for jdoe
Student constructor for jsmith
Student constructor for jbob
login: jdoe
  age: 21
 year: 3
  GPA: 3.25
login: jsmith
  age: 24
 year: 2
  GPA: 4
login: jbob
  age: 23
 year: 4
  GPA: 2.98
***** End *****
Student destructor for jbob
Student destructor for jsmith
Student destructor for jdoe
</pre></blockquote>
</td>
</tr></table>

These three lines:
<blockquote><pre>
Student john(<font color="#9933CC">&quot;jdoe&quot;</font>, 20, 3, 3.10f);
Student jane(<font color="#9933CC">&quot;jsmith&quot;</font>, 19, 2, 3.95f);
Student jim(<font color="#9933CC">&quot;jbob&quot;</font>, 22, 4, 2.76f);
</pre></blockquote>

will look something like this in memory: (the addresses are arbitrary as usual)
<a name="STUDENT_DIAGRAM">
<blockquote>
<img src="Classes-1.png">
</blockquote>
</a>

Notes:
<ul>
<li>Each object is a separate entity in memory, unrelated to the others.
<li>Each object has the same exact <i>structure</i> (layout) in memory, with possibly different values.
<li>The names of the fields are for the programmer's convenience (the compiler discards them during compilation).
<li>A field is accessed via its <i>offset</i> from the address of the object. (Much like how array elements are accessed.)
<li>Like arrays, the address of the first member is the same as the address of the struct/class.
<li>For example, assuming a 32-bit compiler, the compiler finds the <tt>login_</tt> member at offset 0, the <tt>age_</tt> member at offset 4, 
	the <tt>year_</tt> member at offset 8, and the <tt>GPA_</tt> member at offset 12:
<blockquote>
<img src="Student-offsets-1.png">
</blockquote>
<li>Given the diagrams above, this means that the <tt>age_</tt> field for <tt>jane</tt> is at address 204 and the <tt>GPA_</tt>
	field for <tt>jim</tt> is at address 312.
<li>In fact, for any <tt>Student</tt> object at address <i>XYZ</i>, the <tt>age_</tt> member will be at address <i>XYZ + 4</i>. Always.
  <ul>
    <li>This means that, given the address of <i>any</i> object, its members can be found using offsets.</li>
  </ul>
</ul>

<p>
Notice that the methods are <b>not part of the object</b>. This may seem surprising at first. So how does the <i>display</i>
method know which data to show?

<blockquote><pre>
john.display(); 
jane.display();
jim.display();
</pre></blockquote>

<blockquote><pre>
<font color="#003399"><i>// Nowhere does this code reference john, jane, or jim</i></font>
<b>void</b> Student::display()
{
  <b>using</b> std::cout;
  <b>using</b> std::endl;

    <font color="#003399"><i>// These members are just offsets. But offsets from <b>what</b> exactly?</i></font>
  cout &lt;&lt; <font color="#9933CC">&quot;login: &quot;</font> &lt;&lt; <font color="blue">login_</font> &lt;&lt; endl;
  cout &lt;&lt; <font color="#9933CC">&quot;  age: &quot;</font> &lt;&lt; <font color="blue">age_</font> &lt;&lt; endl;
  cout &lt;&lt; <font color="#9933CC">&quot; year: &quot;</font> &lt;&lt; <font color="blue">year_</font> &lt;&lt; endl;
  cout &lt;&lt; <font color="#9933CC">&quot;  GPA: &quot;</font> &lt;&lt; <font color="blue">GPA_</font> &lt;&lt; endl;
}
</pre></blockquote>

<br><br>
